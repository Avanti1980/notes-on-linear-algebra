{"./":{"url":"./","title":"简介","keywords":"","body":"数学笔记 github地址 gitee地址 Copyright © Avanti 2020 all right reserved，powered by Gitbook文件最后修改时间： 2021-06-19 10:20:28 "},"posts/calculus/Wallis-formula.html":{"url":"posts/calculus/Wallis-formula.html","title":"沃利斯公式","keywords":"","body":"　　1655年，英国数学家Wallis写下一个神奇的等式，将\\pi用奇偶数比值的无穷乘积表示了出来： \\begin{align*} \\frac{\\pi}{2} & = \\left( \\frac{2}{1} \\cdot \\frac{2}{3} \\right) \\cdot \\left( \\frac{4}{3} \\cdot \\frac{4}{5} \\right) \\cdot \\left( \\frac{6}{5} \\cdot \\frac{6}{7} \\right) \\cdot \\left( \\frac{8}{7} \\cdot \\frac{8}{9} \\right) \\cdots = \\prod_{n=1}^\\infty \\left( \\frac{2n}{2n-1} \\cdot \\frac{2n}{2n+1} \\right) = \\prod_{n=1}^\\infty \\frac{4n^2}{4n^2-1} \\end{align*} 简单整理可得 \\begin{align*} \\frac{\\pi}{2} = \\lim_{n \\rightarrow \\infty} \\prod_{k=1}^n \\left( \\frac{2k \\cdot 2k}{2k(2k-1)} \\cdot \\frac{2k \\cdot 2k}{(2k+1)2k} \\right) = \\lim_{n \\rightarrow \\infty} \\frac{2^{4n} (n!)^4}{(2n+1) [(2n)!]^2} \\end{align*} 可见\\pi和阶乘存在着某种联系，这为后来Euler发现\\Gamma函数埋下了伏笔。 　　Wallis公式的证明方法很多，本文列出其中4个。 用积分证明 　　这是现代数学教材最常用的证明，由分部积分知 \\begin{align*} I(n) & = \\int_0^\\pi \\sin^n x \\diff x = - \\int_0^\\pi \\sin^{n-1} x \\diff \\cos x = - \\sin^{n-1} x \\cos x |_0^\\pi + \\int_0^\\pi (n-1) \\sin^{n-2} x \\cos^2 x \\diff x \\\\ & = (n-1) \\int_0^\\pi \\sin^{n-2} x (1 - \\sin^2 x) \\diff x = (n-1) I(n-2) - (n-1) I(n) \\\\ & \\Longrightarrow \\frac{I(n)}{I(n-2)} = \\frac{n-1}{n} \\Longrightarrow \\frac{I(2n)}{I(2n-2)} = \\frac{2n-1}{2n} \\Longrightarrow \\frac{I(2n+1)}{I(2n-1)} = \\frac{2n}{2n+1} \\end{align*} 又 \\begin{align*} I(0) = \\int_0^\\pi \\sin^0 x \\diff x = \\pi, \\quad I(1) = \\int_0^\\pi \\sin^1 x \\diff x = - \\cos x |_0^\\pi = 2 \\end{align*} 于是 \\begin{align} \\label{eq: i1} I(2n) & = \\frac{2n-1}{2n} I(2n-2) = \\cdots = \\frac{2n-1}{2n} \\cdot \\frac{2n-3}{2n-2} \\cdots \\frac{1}{2} I(0) = \\pi \\prod_{k=1}^n \\frac{2k-1}{2k} \\\\ \\label{eq: i2} I(2n+1) & = \\frac{2n}{2n+1} I(2n-1) = \\cdots = \\frac{2n}{2n+1} \\cdot \\frac{2n-2}{2n-1} \\cdots \\frac{2}{3} I(1) = 2 \\prod_{k=1}^n \\frac{2k}{2k+1} \\end{align} 显然\\sin^{2n+1} x \\le \\sin^{2n} x \\le \\sin^{2n-1} x，因此I(2n+1) \\le I(2n) \\le I(2n-1)，从而 \\begin{align*} 1 \\le \\frac{I(2n)}{I(2n+1)} \\le \\frac{I(2n-1)}{I(2n+1)} = \\frac{2n+1}{2n} \\end{align*} 由夹逼定理和式(\\ref{eq: i1}-\\ref{eq: i2})知 \\begin{align*} 1 & = \\lim_{n \\rightarrow \\infty} \\frac{I(2n)}{I(2n+1)} = \\frac{\\pi}{2} \\lim_{n \\rightarrow \\infty} \\left( \\prod_{k=1}^n \\frac{2k-1}{2k} / \\prod_{k=1}^n \\frac{2k}{2k+1} \\right) = \\frac{\\pi}{2} \\prod_{k=1}^\\infty \\left( \\frac{2k-1}{2k} \\cdot \\frac{2k+1}{2k} \\right) \\end{align*} 用\\sin x的无穷乘积式证明 　　Wallis公式是\\sin x的无穷乘积式的直接推论。设多项式f(x)的零点为x_1, \\ldots, x_n，则f(x)可因式分解为f(x) = a_0 (x - x_1) (x - x_2) \\cdots (x - x_n)。同理\\sin x的零点为\\pi \\Nbb，因此应该有(该式严格证明并不容易) \\begin{align} \\label{eq: sin-inf-prod} \\frac{\\sin x}{x} = \\left( 1 - \\frac{x^2}{\\pi^2} \\right) \\left( 1 - \\frac{x^2}{4 \\pi^2} \\right) \\left( 1 - \\frac{x^2}{9 \\pi^2} \\right) \\cdots = \\prod_{n=1}^\\infty \\left( 1 - \\frac{x^2}{n^2 \\pi^2} \\right) \\end{align} 代入x = \\pi / 2，立刻可得 \\begin{align*} \\frac{2}{\\pi} = \\prod_{n=1}^\\infty \\left( 1 - \\frac{1}{4 n^2} \\right) = \\prod_{n=1}^\\infty \\frac{4n^2-1}{4n^2} \\end{align*} 顺带一提，式(\\ref{eq: sin-inf-prod})右端x^2的系数为 \\begin{align*} -\\frac{1}{\\pi^2} - \\frac{1}{4 \\pi^2} - \\frac{1}{9 \\pi^2} - \\cdots = - \\frac{1}{\\pi^2} \\sum_{n=1}^\\infty \\frac{1}{n^2} \\end{align*} 又\\sin x的Taylor展式关于x^3的项为-x^3 / 3!，因此 \\begin{align*} -\\frac{1}{3!} = - \\frac{1}{\\pi^2} \\sum_{n=1}^\\infty \\frac{1}{n^2} \\Longrightarrow \\frac{\\pi^2}{6} = \\sum_{n=1}^\\infty \\frac{1}{n^2} \\end{align*} 用Stirling公式证明 　　Stirling公式给出了n!的近似计算方法： \\begin{align*} n! = \\sqrt{2 \\pi n} \\left( \\frac{n}{e} \\right)^n (1 + O (1/n)) \\approx \\sqrt{2 \\pi n} \\left( \\frac{n}{e} \\right)^n \\end{align*} 于是代入可得 \\begin{align*} \\lim_{n \\rightarrow \\infty} \\frac{2^{4n} (n!)^4}{(2n+1) [(2n)!]^2} = \\lim_{n \\rightarrow \\infty} \\frac{2^{4n} (2 \\pi n)^2 (\\frac{n}{e})^{4n} (1 + O (1/n))^4}{(2n+1) 4 \\pi n (\\frac{2n}{e})^{4n} (1 + O (1/2n))^2} = \\lim_{n \\rightarrow \\infty} \\frac{\\pi n}{2n+1} = \\frac{\\pi}{2} \\end{align*} Wallis本人的证明 　　1655年微积分尚处于萌芽阶段，这一年Newton只有13岁，Leibniz只有9岁，Euler和Stirling还没出生，前面证明里用到的那些大杀器还没现世。当时的数学家们只得到了如下结果：将[0,1]分割为无穷个小区间[r,1], [r^2, r], [r^3,r^2], \\ldots，则 \\begin{align*} \\int_0^1 x^n \\diff x & = \\lim_{r \\rightarrow 1-} \\sum_{i=1}^\\infty (r^{i-1} - r^i) (r^i)^n = \\lim_{r \\rightarrow 1-} \\sum_{i=1}^\\infty \\frac{1-r}{r} (r^{n+1})^i = \\lim_{r \\rightarrow 1-} \\frac{1-r}{r} \\frac{r^{n+1}}{1 - r^{n+1}} \\\\ & = \\lim_{r \\rightarrow 1-} \\frac{r^n}{1 + r + r^2 + \\cdots r^n} = \\frac{1}{n+1}, \\quad n \\in \\Nbb \\end{align*} 即在区间[0,1]上，x轴与曲线x^n围成的面积为1 / (n+1)。 　　Wallis对\\pi感兴趣，于是他把曲线换成了单位圆的方程y = (1 - x^2)^{1/2}，显然在区间[0,1]上其与x轴围成的面积为\\pi / 4，同样经过无穷分割有 \\begin{align*} \\frac{\\pi}{4} = \\lim_{n \\rightarrow \\infty} \\sum_{k=1}^n \\frac{1}{n} \\left( 1 - \\frac{k^2}{n^2} \\right)^{1/2} \\end{align*} 右边的无穷乘积式难以进一步处理，于是Wallis转而考虑更一般形式的曲线积分 \\begin{align*} A(p,q) = \\int_0^1 \\left( 1 - x^{\\frac{1}{p}} \\right)^q \\diff x \\end{align*} 单位圆方程是该式的一个特例，即A ( \\frac{1}{2}, \\frac{1}{2} ) = \\pi / 4。易知 \\begin{align*} A(p,q) = \\int_0^1 \\left( 1 - x^{\\frac{1}{p}} \\right)^{q-1} \\left( 1 - x^{\\frac{1}{p}} \\right) \\diff x = A(p,q-1) - \\int_0^1 \\class{blue}{\\left( 1 - x^{\\frac{1}{p}} \\right)^{q-1} x^{\\frac{1}{p}} \\diff x} \\end{align*} 注意 \\begin{align*} \\diff \\left( 1 - x^{\\frac{1}{p}} \\right)^q = q \\left( 1 - x^{\\frac{1}{p}} \\right)^{q-1} (-1) \\frac{1}{p} x^{\\frac{1-p}{p}} \\diff x = -\\frac{q}{px} \\class{blue}{\\left( 1 - x^{\\frac{1}{p}} \\right)^{q-1} x^{\\frac{1}{p}} \\diff x} \\end{align*} 故 \\begin{align*} A(p,q) & = A(p,q-1) + \\int_0^1 \\frac{px}{q} \\diff \\left( 1 - x^{\\frac{1}{p}} \\right)^q = A(p,q-1) + \\left. \\frac{px}{q} \\left( 1 - x^{\\frac{1}{p}} \\right)^q \\right|_0^1 - \\frac{p}{q} \\int_0^1 \\left( 1 - x^{\\frac{1}{p}} \\right)^q \\diff x \\\\ & = A(p,q-1) - \\frac{p}{q} A(p,q) \\\\ & \\Longrightarrow \\frac{A(p,q)}{A(p,q-1)} = \\frac{q}{q+p} \\end{align*} 又 \\begin{align*} A(p,1) = \\int_0^1 ( 1 - x^{\\frac{1}{p}}) \\diff x = 1 - \\left. \\frac{p}{p+1} x^{\\frac{p+1}{p}} \\right|_0^1 = \\frac{1}{p+1} \\end{align*} 于是 \\begin{align} \\label{eq: apq} A(p,q) = \\frac{q}{q+p} A(p,q-1) = \\frac{q}{q+p} \\cdot \\frac{q-1}{q+p-1} \\cdots \\frac{2}{p+2} \\cdot \\frac{1}{p+1} = \\class{blue}{\\frac{p!q!}{(q+p)!}} \\end{align} 尽管上式是针对正整数p、q得到的，但Wallis猜测它们对分数p、q也成立，令p = 1/2、q为任意正整数可得 \\begin{align*} A \\left( \\frac{1}{2}, q \\right) & = \\frac{q}{q+\\frac{1}{2}} \\cdot \\frac{q-1}{q-\\frac{1}{2}} \\cdots \\frac{2}{\\frac{1}{2}+2} \\cdot \\frac{1}{\\frac{1}{2}+1} = \\frac{2q}{2q+1} \\cdot \\frac{2q-2}{2q-1} \\cdots \\frac{4}{5} \\cdot \\frac{2}{3} \\\\ A \\left( \\frac{1}{2}, q+\\frac{1}{2} \\right) & = \\frac{q+\\frac{1}{2}}{q+1} \\cdot \\frac{q-\\frac{1}{2}}{q} \\cdots \\frac{\\frac{5}{2}}{3} \\cdot \\frac{\\frac{3}{2}}{2} A \\left( \\frac{1}{2}, \\frac{1}{2} \\right) = \\frac{2q+1}{2q+2} \\cdot \\frac{2q-1}{2q} \\cdots \\frac{5}{6} \\cdot \\frac{3}{4} A \\left( \\frac{1}{2}, \\frac{1}{2} \\right) \\end{align*} 由于1 - x^{\\frac{1}{p}} \\in [0,1]，因此A(p,q)是关于q的单调减函数，于是 \\begin{align*} A \\left( \\frac{1}{2}, q-\\frac{1}{2} \\right) \\ge A \\left( \\frac{1}{2}, q \\right) \\ge A \\left( \\frac{1}{2}, q+\\frac{1}{2} \\right) = \\frac{q+\\frac{1}{2}}{q+1} A \\left( \\frac{1}{2}, q-\\frac{1}{2} \\right) \\end{align*} 由夹逼定理知\\lim_{q \\rightarrow \\infty} A ( \\frac{1}{2}, q ) = \\lim_{q \\rightarrow \\infty} A ( \\frac{1}{2}, q+\\frac{1}{2} )，即 \\begin{align*} \\lim_{q \\rightarrow \\infty} \\frac{2q}{2q+1} \\cdot \\frac{2q-2}{2q-1} \\cdots \\frac{4}{5} \\cdot \\frac{2}{3} = \\lim_{q \\rightarrow \\infty} \\frac{2q+1}{2q+2} \\cdot \\frac{2q-1}{2q} \\cdots \\frac{5}{6} \\cdot \\frac{3}{4} A \\left( \\frac{1}{2}, \\frac{1}{2} \\right) \\end{align*} 整理可得 \\begin{align*} \\frac{\\pi}{4} = A \\left( \\frac{1}{2}, \\frac{1}{2} \\right) = \\frac{2}{3} \\cdot \\frac{4}{3} \\cdot \\frac{4}{5} \\cdot \\frac{6}{5} \\cdot \\frac{6}{7} \\cdot \\frac{8}{7} \\cdot \\frac{8}{9}\\cdots \\end{align*} 　　Wallis对式(\\ref{eq: apq})取分数p、q其实隐含假设了阶乘对分数也有定义，因此这个证明并不严格，但这为后来Euler研究阶乘的插值提供了线索。此外对式(\\ref{eq: apq})令p = q = 1/2可得 \\begin{align*} \\frac{\\pi}{4} = A \\left( \\frac{1}{2}, \\frac{1}{2} \\right) = \\left( \\frac{1}{2} \\right)! \\left( \\frac{1}{2} \\right)! \\Longrightarrow \\left( \\frac{1}{2} \\right)! = \\frac{\\sqrt{\\pi}}{2} \\end{align*} Copyright © Avanti 2020 all right reserved，powered by Gitbook文件最后修改时间： 2021-06-19 10:20:29 "},"posts/calculus/gamma.html":{"url":"posts/calculus/gamma.html","title":"伽玛函数","keywords":"","body":"　　1655年，Wallis在研究单位圆方程y = (1 - x^2)^{1/2}下的面积时得到了Wallis公式： \\begin{align*} \\frac{\\pi}{2} & = \\left( \\frac{2}{1} \\cdot \\frac{2}{3} \\right) \\cdot \\left( \\frac{4}{3} \\cdot \\frac{4}{5} \\right) \\cdot \\left( \\frac{6}{5} \\cdot \\frac{6}{7} \\right) \\cdot \\left( \\frac{8}{7} \\cdot \\frac{8}{9} \\right) \\cdots = \\prod_{n=1}^\\infty \\left( \\frac{2n}{2n-1} \\cdot \\frac{2n}{2n+1} \\right) = \\prod_{n=1}^\\infty \\frac{4n^2}{4n^2-1} \\end{align*} 但他的推导并不严格，用到了分数的阶乘，而如何将阶乘从正整数插值到分数当时尚不清楚。进入十八世纪后，Goldbach率先开始考虑阶乘的插值问题，但一直不得要领，便向其他数学家好友求助。1729年，Bernoulli家族的Daniel Bernoulli给出了一个无穷乘积形式的结果： \\begin{align*} n! = \\lim_{m \\rightarrow \\infty} \\left( m + 1 + \\frac{n}{2} \\right)^{n-1} \\prod_{k=1}^m \\frac{k+1}{k+n} \\end{align*} 将阶乘的定义延拓到了实数集。 Euler的发现 　　Euler与Daniel的私交甚好，在得知Daniel在研究阶乘的插值问题后，也开始了自己的探索，首先他发现对任意自然数n和m有： \\begin{align*} \\lim_{m \\rightarrow \\infty} \\frac{(m+1)^n}{(m+n) \\cdots (m+1)} = 1 \\Longrightarrow \\lim_{m \\rightarrow \\infty} \\frac{(m+1)^n m!}{(m+n)!} = 1 \\end{align*} 于是有 \\begin{align*} n! & = n! \\lim_{m \\rightarrow \\infty} \\frac{(m+1)^n m!}{(m+n)!} = \\lim_{m \\rightarrow \\infty} \\frac{\\class{green}{(m+1)^n} \\class{blue}{m!}}{\\class{red}{(n+1)(n+2)\\cdots(n+m)}} \\\\ & = \\left[ \\class{green}{\\left( \\frac{2}{1} \\right)^n} \\frac{\\class{blue}{1}}{\\class{red}{n+1}} \\right] \\cdot \\left[ \\class{green}{\\left( \\frac{3}{2} \\right)^n} \\frac{\\class{blue}{2}}{\\class{red}{n+2}} \\right] \\cdot \\left[ \\class{green}{\\left( \\frac{4}{3} \\right)^n} \\frac{\\class{blue}{3}}{\\class{red}{n+3}} \\right] \\cdots \\end{align*} 这样Euler也得到了一个n!的无穷乘积式。 　　就收敛到n!的速度来说，Daniel的无穷乘积式比Euler的要快得多，但Euler的无穷乘积式更方便进一步挖掘，例如令n = 1/2有 \\begin{align*} \\left(\\frac{1}{2}\\right)! = \\sqrt{ \\left[ \\frac{\\class{green}{2}}{\\class{blue}{1}} \\cdot \\frac{\\class{blue}{1^2 \\cdot 2} \\cdot \\class{green}{2}}{3 \\cdot 3} \\right] \\cdot \\left[ \\frac{\\class{green}{3}}{\\class{blue}{2}} \\cdot \\frac{\\class{blue}{2^2 \\cdot 2} \\cdot \\class{green}{2}}{5 \\cdot 5} \\right] \\cdot \\left[ \\frac{\\class{green}{4}}{\\class{blue}{3}} \\cdot \\frac{\\class{blue}{3^2 \\cdot 2} \\cdot \\class{green}{2}}{7 \\cdot 7} \\right] \\cdots} = \\sqrt{\\frac{\\class{blue}{2} \\cdot \\class{green}{4}}{3 \\cdot 3} \\cdot \\frac{\\class{blue}{4} \\cdot \\class{green}{6}}{5 \\cdot 5} \\cdot \\frac{\\class{blue}{6} \\cdot \\class{green}{8}}{7 \\cdot 7} \\cdots} \\end{align*} 最后一项不正是Wallis公式么？于是立刻得到 \\begin{align*} \\left(\\frac{1}{2}\\right)! = \\frac{\\sqrt{\\pi}}{2} \\end{align*} 　　在Euler这样的大师眼里，一旦扯上\\pi，自然就和圆相关的积分逃不了干系，那么n!应该也可以表示成某种积分的形式，于是Euler开始考虑一般形式的积分 \\begin{align} \\label{eq: first-integral-raw} E(m,n) = \\int_0^1 x^m (1-x)^n \\diff x \\end{align} 其中m是正实数，n是正整数。由分部积分有 \\begin{align*} E(m,n) & = \\frac{1}{m+1} \\int_0^1 (1-x)^n \\diff x^{m+1} = \\left. \\frac{1}{m+1} x^{m+1} (1-x)^n \\right|_0^1 - \\frac{1}{m+1} \\int_0^1 x^{m+1} \\diff (1-x)^n \\\\ & = \\frac{n}{m+1} \\int_0^1 x^{m+1}(1-x)^{n-1} \\diff x = \\frac{n}{m+1} E(m+1,n-1) \\end{align*} 又 \\begin{align*} E(m+n,0) = \\int_0^1 x^{m+n} \\diff x = \\frac{1}{m+n+1} \\end{align*} 于是 \\begin{align} \\label{eq: E} E(m,n) = \\frac{n}{m+1} \\cdot \\frac{n-1}{m+2} \\cdots \\frac{1}{m+n} E(m+n,0) = \\frac{n}{m+1} \\cdot \\frac{n-1}{m+2} \\cdots \\frac{1}{m+n} \\cdot \\frac{1}{m+n+1} \\end{align} 整理可得 \\begin{align*} \\frac{n!}{(m+1)(m+2) \\cdots (m+n)} = (m+n+1) \\int_0^1 x^m (1-x)^n \\diff x \\end{align*} 为了将n!摘出来，Euler先做变量代换m = u/v，于是 \\begin{align} \\label{eq: Euler trick} \\frac{n!}{(u+v)(u+2v)\\cdots (u+nv)} = \\frac{u+(n+1)v}{v^{n+1}} \\int_0^1 x^{u/v} (1-x)^n \\diff x \\end{align} 注意当u \\rightarrow 1且v \\rightarrow 0时，式(\\ref{eq: Euler trick})左端\\rightarrow n!，对右端继续做变量代换x = y^{v/(u+v)}，注意 \\begin{align*} x^{u/v} = y^{u/(u+v)}, \\quad \\diff x = \\frac{v}{u+v} y^{-u/(u+v)} \\diff y \\end{align*} 故式(\\ref{eq: Euler trick})右端变为 \\begin{align*} \\frac{u+(n+1)v}{v^{n+1}} \\int_0^1 y^{u/(u+v)} (1-y^{v/(u+v)})^n \\frac{v}{u+v} y^{-u/(u+v)} \\diff y & = \\frac{u+(n+1)v}{v^n (u+v)} \\int_0^1 (1-y^{v/(u+v)})^n \\diff y \\\\ & = \\frac{u+(n+1)v}{(u+v)^{n+1}} \\int_0^1 \\left(\\frac{1-y^{v/(u+v)}}{v/(u+v)}\\right)^n \\diff y \\end{align*} 综上我们有 \\begin{align*} n! = \\lim_{u \\rightarrow 1, v \\rightarrow 0} \\frac{u+(n+1)v}{(u+v)^{n+1}} \\int_0^1 \\left(\\frac{1-y^{v/(u+v)}}{v/(u+v)}\\right)^n \\diff y = \\int_0^1 \\lim_{x \\rightarrow 0} \\left(\\frac{1-y^x}{x}\\right)^n \\diff y = \\int_0^1 \\left(\\lim_{x \\rightarrow 0} \\frac{1-y^x}{x}\\right)^n \\diff y \\end{align*} 其中第二个等号交换取极限和求积分不是恒成立的，由L'Hospital法则知 \\begin{align*} \\lim_{x \\rightarrow 0} \\frac{1-y^x}{x} = \\lim_{x \\rightarrow 0} -y^x \\ln y = - \\ln y \\end{align*} 这样就得到了阶乘的积分表达式 \\begin{align*} n! = \\int_0^1 ( - \\ln y )^n \\diff y \\end{align*} 做变量代换x = -\\ln y，即y = e^{-x}，可得 \\begin{align*} n! = \\int_\\infty^0 x^n (- e^{-x}) \\diff x = \\int_0^\\infty e^{-x} x^n \\diff x \\end{align*} 　　记 \\begin{align} \\label{eq: second-integral-raw} \\gamma(n) = \\int_0^\\infty e^{-x} x^n \\diff x \\end{align} 则对于正整数n有\\gamma(n) = n!，此外有递推关系 \\begin{align*} \\gamma(n) = - \\int_0^\\infty x^n \\diff e^{-x} = - x^n e^{-x} |_0^\\infty + \\int_0^\\infty e^{-x} n x^{n-1} \\diff x = n \\cdot \\gamma(n-1) \\end{align*} 于是两个积分之间有如下关系： \\begin{align*} E(m,n) = \\frac{n!}{(m+1)(m+2)\\cdots(m+n)(m+n+1)} = \\frac{\\gamma (m) \\gamma (n)}{\\gamma (m+n+1)} \\end{align*} 后来可能是出于美观的原因吧，Legendre将式(\\ref{eq: first-integral-raw})、式(\\ref{eq: second-integral-raw})分别修改为 \\begin{align} \\label{eq: first-second-integral} B(m,n) = \\int_0^1 x^{m-1} (1-x)^{n-1} \\diff x, \\quad \\Gamma(n) = \\int_0^\\infty e^{-x} x^{n-1} \\diff x \\end{align} 即指数中的m和n均偏移了1，于是对于正整数n有\\Gamma(n) = (n-1)!且有递推关系 \\begin{align*} \\Gamma(n) = \\gamma(n-1) = (n-1) \\gamma (n-2) = (n-1) \\Gamma (n-1) \\end{align*} 此外两个积分之间有如下关系： \\begin{align*} B(m,n) = E(m-1,n-1) = \\frac{\\gamma (m-1) \\gamma (n-1)}{\\gamma (m+n-1)} = \\frac{\\Gamma (m) \\Gamma (n)}{\\Gamma (m+n)} \\end{align*} 式(\\ref{eq: first-second-integral})中的B函数和\\Gamma函数分别被称为Euler第一型积分和Euler第二型积分。 \\Gamma函数的等价形式 　　\\Gamma函数除了Euler给出的 \\begin{align*} \\Gamma(n) = \\int_0^\\infty e^{-x} x^{n-1} \\diff x = \\int_0^1 ( - \\ln y )^{n-1} \\diff y = \\int_0^\\infty e^{-e^z} e^{nz} \\diff z \\end{align*} 这几种形式外(最后一个形式可通过变量代换x = e^z得到)，还有许多等价形式。 Gauss形式 　　注意 \\begin{align*} e = \\lim_{m \\rightarrow \\infty} \\left( 1 + \\frac{1}{m} \\right)^m = \\lim_{m \\rightarrow \\infty} \\left( 1 + \\frac{1}{-m/x} \\right)^{-m/x} \\Longrightarrow e^{-x} = \\lim_{m \\rightarrow \\infty} \\left( 1 - \\frac{x}{m} \\right)^m \\end{align*} 于是 \\begin{align*} \\Gamma(n) = \\int_0^\\infty e^{-x} x^{n-1} \\diff x = \\lim_{m \\rightarrow \\infty} \\int_0^m \\left( 1 - \\frac{x}{m} \\right)^m x^{n-1} \\diff x \\end{align*} 由分部积分有 \\begin{align*} S & = \\int_0^m \\left( 1 - \\frac{x}{m} \\right)^m x^{n-1} \\diff x = \\frac{1}{n} \\int_0^m \\left( 1 - \\frac{x}{m} \\right)^m \\diff x^n \\\\ & = \\frac{x^n}{n} \\left. \\left( 1 - \\frac{x}{m} \\right)^m \\right|_0^m - \\frac{1}{n} \\int_0^m x^n m \\left( 1 - \\frac{x}{m} \\right)^{m-1} \\left( - \\frac{1}{m} \\right) \\diff x \\\\ & = \\frac{m}{mn} \\int_0^m \\left( 1 - \\frac{x}{m} \\right)^{m-1} x^n \\diff x \\end{align*} 注意系数分子中的m是由对(1 - \\square)^m求导而来(该项会一直变)，分母中的m是由对1 - x / m求导而来(该项不会变)，分母中的n是对x^{n-1}积分而得(该项会一直变)，因此 \\begin{align*} S & = \\frac{m}{mn} \\int_0^m \\left( 1 - \\frac{x}{m} \\right)^{m-1} x^n \\diff x = \\frac{m}{mn} \\cdot \\frac{m-1}{m(n+1)} \\int_0^m \\left( 1 - \\frac{x}{m} \\right)^{m-2} x^{n+1} \\diff x \\\\ & = \\frac{m}{mn} \\cdot \\frac{m-1}{m(n+1)} \\cdots \\frac{1}{m(n+m-1)} \\int_0^m \\left( 1 - \\frac{x}{m} \\right)^0 x^{n+m-1} \\diff x \\\\ & = \\frac{m}{mn} \\cdot \\frac{m-1}{m(n+1)} \\cdots \\frac{1}{m(n+m-1)} \\cdot \\frac{m^{n+m}}{n+m} \\\\ & = \\frac{m^n m!}{n (n+1) \\cdots (n+m)} = \\frac{m^n}{n} \\prod_{k=1}^m \\frac{k}{n+k} \\end{align*} 这样就得到了Gauss形式的\\Gamma函数： \\begin{align} \\label{eq: gauss} \\Gamma(n) = \\lim_{m \\rightarrow \\infty} \\frac{m^n}{n} \\prod_{k=1}^m \\frac{k}{n+k} = \\lim_{m \\rightarrow \\infty} \\frac{m^n m!}{n (n+1) \\cdots (n+m)} \\end{align} Weierstrass形式 　　引入Euler-Mascheroni常数 \\begin{align*} \\gamma = \\lim_{m \\rightarrow \\infty} \\left( \\sum_{k=1}^m \\frac{1}{k} - \\ln m \\right) = \\int_1^\\infty \\left( \\frac{1}{\\lfloor x \\rfloor} - \\frac{1}{x} \\right) \\diff x \\end{align*} 注意 \\begin{align*} m^n = e^{n \\log m} = \\exp \\left( n \\sum_{k=1}^m \\frac{1}{k} - n \\sum_{k=1}^m \\frac{1}{k} + n \\ln m \\right) = \\exp \\left( - n \\left( \\sum_{k=1}^m \\frac{1}{k} - \\ln m \\right) \\right) \\prod_{k=1}^m e^{n/k} \\end{align*} 代入式(\\ref{eq: gauss})即可得Weierstrass形式的\\Gamma函数： \\begin{align*} \\Gamma(n) = \\lim_{m \\rightarrow \\infty} \\frac{1}{n} \\exp \\left( - n \\left( \\sum_{k=1}^m \\frac{1}{k} - \\ln m \\right) \\right) \\left( \\prod_{k=1}^m e^{n/k} \\right) \\left( \\prod_{k=1}^m \\frac{k}{n+k} \\right) = \\frac{e^{-n \\gamma}}{n} \\prod_{k=1}^\\infty e^{n/k} \\left( 1 + \\frac{n}{k} \\right)^{-1} \\end{align*} \\Gamma函数的性质 　　本节证明Euler反射公式、Legendre倍元公式、Gauss乘法公式和Bohr-Mollerup定理。 Euler反射公式 　　根据Gauss形式 \\begin{align*} \\Gamma(n) = \\lim_{m \\rightarrow \\infty} \\frac{m^n m!}{n (n+1) \\cdots (n+m)} = (n-1) \\lim_{m \\rightarrow \\infty} \\frac{m^{n-1} m!}{(n-1) n \\cdots (n+m-1)} \\frac{m}{n+m} = (n-1) \\Gamma(n-1) \\end{align*} 注意该式不需要n为正整数。代入n = \\pm n有 \\begin{align*} \\Gamma(n) = \\lim_{m \\rightarrow \\infty} \\frac{m^n}{n} \\prod_{k=1}^m \\frac{k}{n+k}, \\quad \\Gamma(-n) = \\lim_{m \\rightarrow \\infty} \\frac{m^{-n}}{-n} \\prod_{k=1}^m \\frac{k}{-n+k} \\end{align*} 两式相乘可得 \\begin{align*} \\Gamma(n) \\Gamma(-n) = \\frac{-1}{n^2} \\prod_{k=1}^\\infty \\frac{k^2}{k^2 - n^2} = \\frac{-1}{n^2} \\prod_{k=1}^\\infty \\left( 1 - \\frac{n^2}{k^2} \\right)^{-1} = \\frac{-1}{n^2} \\frac{\\pi n}{\\sin \\pi n} = \\frac{1}{-n} \\frac{\\pi}{\\sin \\pi n} \\end{align*} 其中倒数第二个等号是根据\\sin x的无穷乘积式 \\begin{align*} \\frac{\\sin x}{x} = \\left( 1 - \\frac{x^2}{\\pi^2} \\right) \\left( 1 - \\frac{x^2}{4 \\pi^2} \\right) \\left( 1 - \\frac{x^2}{9 \\pi^2} \\right) \\cdots = \\prod_{k=1}^\\infty \\left( 1 - \\frac{x^2}{k^2 \\pi^2} \\right) \\Longrightarrow \\frac{\\sin \\pi n}{\\pi n} = \\prod_{k=1}^\\infty \\left( 1 - \\frac{n^2}{k^2} \\right) \\end{align*} 于是可得Euler反射公式： \\begin{align*} \\frac{\\pi}{\\sin \\pi n} = \\Gamma(n) (-n \\Gamma(-n) ) = \\Gamma(n) \\Gamma(1-n) \\end{align*} Legendre倍元公式 　　对B函数做变量代换x = \\sin^2 y，即\\diff x = 2 \\sin y \\cos y \\diff y，可得 \\begin{align*} B(m,n) & = \\int_0^1 x^{m-1} (1-x)^{n-1} \\diff x = \\int_0^{\\frac{\\pi}{2}} \\sin^{2m-2} y \\cos^{2n-2} y 2 \\sin y \\cos y \\diff y \\\\ & = 2 \\int_0^{\\frac{\\pi}{2}} \\sin^{2m-1} y \\cos^{2n-1} y \\diff y \\end{align*} 于是 \\begin{align*} I = \\frac{\\Gamma (z) \\Gamma (z)}{2\\Gamma (2z)} = \\frac{B(z,z)}{2} = \\int_0^{\\frac{\\pi}{2}} \\sin^{2z-1} y \\cos^{2z-1} y \\diff y = 2^{1-2z} \\int_0^{\\frac{\\pi}{2}} \\sin^{2z-1} 2y \\diff y = 2^{-2z} \\int_0^{\\pi} \\sin^{2z-1} y \\diff y \\end{align*} 由于\\sin y关于y = \\pi/2对称，因此 \\begin{align*} \\frac{\\Gamma (z) \\Gamma (z)}{2\\Gamma (2z)} = I = 2^{-2z} \\int_0^{\\pi} \\sin^{2z-1} y \\diff y = 2^{1-2z} \\int_0^{\\frac{\\pi}{2}} \\sin^{2z-1} y \\diff y = 2^{-2z} B \\left( z, \\frac{1}{2} \\right) = 2^{-2z} \\frac{\\Gamma(z) \\Gamma \\left( \\frac{1}{2} \\right)}{\\Gamma \\left( z+\\frac{1}{2} \\right)} \\end{align*} 注意\\Gamma \\left( \\frac{1}{2} \\right) = 2 \\Gamma \\left( \\frac{3}{2} \\right) = 2 \\left( \\frac{1}{2} \\right)! = \\sqrt{\\pi}，整理可得Legendre倍元公式： \\begin{align*} \\Gamma (z) \\Gamma \\left( z+\\frac{1}{2} \\right) = 2^{1-2z} \\Gamma (2z) \\Gamma \\left( \\frac{1}{2} \\right) = 2^{1-2z} \\sqrt{\\pi} \\Gamma (2z) = (2 \\pi)^{\\frac{1}{2}} 2^{\\frac{1}{2} - 2z} \\Gamma (2z) \\end{align*} Gauss乘法公式 　　事实上，Legendre倍元公式是Gauss乘法公式 \\begin{align*} \\prod_{k=0}^{n-1} \\Gamma \\left( z + \\frac{k}{n} \\right) = (2 \\pi)^{\\frac{n-1}{2}} n^{\\frac{1}{2} - nz} \\Gamma (nz), \\quad \\forall z \\not \\in \\left\\{ - \\frac{l}{n} : l \\in \\Nbb \\right\\} \\end{align*} 在n=2时的特例。根据Gauss形式和Stirling公式 \\begin{align*} \\Gamma(n) = \\lim_{m \\rightarrow \\infty} \\frac{m^n m!}{n (n+1) (n+2) \\cdots (n+m)}, \\quad m! = \\sqrt{2 \\pi m} \\left( \\frac{m}{e} \\right)^m (1 + O (1/m)) \\end{align*} 易知有 \\begin{align*} \\Gamma \\left( z + \\frac{k}{n} \\right) & = \\left( z + \\frac{k}{n} - 1 \\right) \\Gamma \\left( z + \\frac{k}{n} - 1 \\right) \\\\ & = \\left( z + \\frac{k}{n} - 1 \\right) \\lim_{m \\rightarrow \\infty} \\frac{m^{z + \\frac{k}{n} - 1} m!}{\\left( z + \\frac{k}{n} - 1 \\right) \\left( z + \\frac{k}{n} \\right) \\left( z + \\frac{k}{n} + 1 \\right) \\cdots \\left( z + \\frac{k}{n} - 1 + m \\right)} \\\\ & = \\lim_{m \\rightarrow \\infty} \\frac{m^{z + \\frac{k}{n} - 1} \\sqrt{2 \\pi m} \\left( \\frac{m}{e} \\right)^m}{\\left( z + \\frac{k}{n} \\right) \\left( z + \\frac{k}{n} + 1 \\right) \\cdots \\left( z + \\frac{k}{n} - 1 + m \\right)} \\\\ & = (2 \\pi)^\\frac{1}{2} \\lim_{m \\rightarrow \\infty} \\frac{m^{z + \\frac{k}{n} - \\frac{1}{2}} \\left( \\frac{mn}{e} \\right)^m}{(nz+k) (nz+k+n) \\cdots (nz+k-n+mn)} \\end{align*} 于是 \\begin{align*} \\prod_{k=0}^{n-1} \\Gamma \\left( z + \\frac{k}{n} \\right) & = (2 \\pi)^\\frac{n}{2} \\lim_{m \\rightarrow \\infty} \\frac{m^{nz-\\frac{n}{2}} m^{\\sum_{k=0}^{n-1} \\frac{k}{n}} \\left( \\frac{mn}{e} \\right)^{mn}}{(nz) (nz+1) \\cdots (nz-1+mn)} \\\\ & = (2 \\pi)^\\frac{n}{2} \\lim_{m \\rightarrow \\infty} \\frac{m^{nz-\\frac{1}{2}} \\left( \\frac{mn}{e} \\right)^{mn}}{(nz) (nz+1) \\cdots (nz-1+mn)} \\\\ & = (2 \\pi)^\\frac{n}{2} n^{\\frac{1}{2}-nz} \\lim_{m \\rightarrow \\infty} \\frac{m^{nz-\\frac{1}{2}} \\left( \\frac{m}{e} \\right)^m}{(nz) (nz+1) \\cdots (nz-1+m)} \\\\ & = (2 \\pi)^\\frac{n-1}{2} n^{\\frac{1}{2}-nz} \\lim_{m \\rightarrow \\infty} \\frac{m^{nz-1} m!}{(nz) (nz+1) \\cdots (nz-1+m)} \\\\ & = (2 \\pi)^\\frac{n-1}{2} n^{\\frac{1}{2}-nz} (nz-1) \\lim_{m \\rightarrow \\infty} \\frac{m^{nz-1} m!}{(nz-1) (nz) (nz+1) \\cdots (nz-1+m)} \\\\ & = (2 \\pi)^\\frac{n-1}{2} n^{\\frac{1}{2}-nz} (nz-1) \\Gamma (nz-1) \\\\ & = (2 \\pi)^\\frac{n-1}{2} n^{\\frac{1}{2}-nz} \\Gamma (nz) \\end{align*} Bohr-Mollerup定理 　　阶乘的插值函数并不唯一，但同时满足1) f(1) = 1；2) f(n+1) = n f(n)；3) \\ln f是凸函数 这三个条件的只有\\Gamma函数。 　　设函数f(n)满足这三个条件，根据第2个条件可知对任意正整数m有 \\begin{align*} f(n+m) = (n+m-1) (n+m-2) \\cdots (n+1) n f (n) \\end{align*} 即f(n+m)可完全由f(n)决定，因此只需考虑(0,1]上的f(n)。此外令n=1，根据第1个条件可知f(m+1) = m!。 　　对任意n_1 ，设S(n_1, n_2)为连接两点(n_1, \\ln f(n_1))、(n_2, \\ln f(n_2))的直线斜率，即 \\begin{align*} S(n_1, n_2) = \\frac{\\ln f(n_2) - \\ln f(n_1)}{n_2 - n_1} \\end{align*} 由附录中的定理1知S(n_1, n_2)关于n_1、n_2均是单调增函数，于是对\\forall n \\in (0,1]有 \\begin{align*} & \\qquad ~ S(m-1, m) \\le S(m, m+n) \\le S(m, m+1) \\\\ & \\Longleftrightarrow \\frac{\\ln f(m) - \\ln f(m-1)}{1} \\le \\frac{\\ln f(m+n) - \\ln f(m)}{n} \\le \\frac{\\ln f(m+1) - \\ln f(m)}{1} \\\\ & \\Longleftrightarrow \\frac{\\ln (m-1)}{1} \\le \\frac{\\ln f(m+n) - \\ln f(m)}{n} \\le \\frac{\\ln m}{1} \\\\ & \\Longleftrightarrow \\ln f(m) + n \\ln (m-1) \\le \\ln f(m+n) \\le \\ln f(m) + n \\ln m \\\\ & \\Longleftrightarrow (m-1)^n (m-1)! \\le f(m+n) \\le m^n (m-1)! \\end{align*} 于是代入可得 \\begin{align*} \\frac{(m-1)^n (m-1)!}{(n+m-1) (n+m-2) \\cdots (n+1) n} \\le f(n) \\le \\frac{m^n m!}{(n+m) (n+m-1) (n+m-2) \\cdots (n+1) n} \\cdot \\frac{n+m}{m} \\end{align*} 注意中间项f(n)与m无关，因此左半、右半部分中的m可以各自取值，现令左半的m = m+1、右半的m = m可得 \\begin{align*} \\frac{m^n m!}{(n+m) (n+m-1) \\cdots (n+1) n} \\le f(n) \\le \\frac{m^n m!}{(n+m) (n+m-1) (n+m-2) \\cdots (n+1) n} \\cdot \\frac{n+m}{m} \\end{align*} 由夹逼定理知 \\begin{align*} f(n) = \\lim_{m \\rightarrow \\infty} \\frac{m^n m!}{(n+m) (n+m-1) \\cdots (n+1) n} = \\Gamma(n) \\end{align*} 即在(0,1]上满足三个条件的函数就是\\Gamma函数。又 \\begin{align*} f(n+1) = n f(n) & = n \\lim_{m \\rightarrow \\infty} \\frac{m^n m!}{(n+m) (n+m-1) \\cdots (n+1) n} \\\\ & = \\lim_{m \\rightarrow \\infty} \\frac{m^n m!}{(n+m) (n+m-1) \\cdots (n+1)} \\cdot \\frac{m}{n+m+1} \\\\ & = \\Gamma(n+1) \\end{align*} 即在(1,2]上满足三个条件的函数依然是\\Gamma函数，依次类推在(0, \\infty)上满足三个条件的函数就是\\Gamma函数。 附录 定理1：对于凸函数f: \\Rbb \\mapsto \\Rbb上的两点(x_1, f(x_1))、(x_2, f(x_2))，连接其直线的斜率 \\begin{align*} S(x_1, x_2) = \\frac{f(x_2) - f(x_1)}{x_2 - x_1} \\end{align*} 关于x_1、x_2均是单调增函数。 证明：不妨设x_1 ，对\\forall \\alpha \\in (0,1)，记\\xhat = \\alpha x_1 + (1 - \\alpha) x_2，即x_1 ，易知有 \\begin{align*} \\xhat - x_1 = (1 - \\alpha) (x_2 - x_1), \\quad x_2 - \\xhat = \\alpha (x_2 - x_1) \\end{align*} 根据f的凸性知\\alpha f(x_1) + (1 - \\alpha) f(x_2) \\ge f(\\xhat)，于是 \\begin{align*} f(\\xhat) - f(x_1) \\le (1 - \\alpha) (f(x_2) - f(x_1)), \\quad f(x_2) - f(\\xhat) \\ge \\alpha (f(x_2) - f(x_1)) \\end{align*} 联立整理可得 \\begin{align*} \\frac{f(\\xhat) - f(x_1)}{1 - \\alpha} \\le f(x_2) - f(x_1) \\le \\frac{f(x_2) - f(\\xhat)}{\\alpha} \\end{align*} 同除以x_2 - x_1可得 \\begin{align*} \\frac{f(\\xhat) - f(x_1)}{\\xhat - x_1} = \\frac{f(\\xhat) - f(x_1)}{(1 - \\alpha)(x_2 - x_1)} \\le \\frac{f(x_2) - f(x_1)}{x_2 - x_1} \\le \\frac{f(x_2) - f(\\xhat)}{\\alpha(x_2 - x_1)} = \\frac{f(x_2) - f(\\xhat)}{x_2 - \\xhat} \\end{align*} 即S(x_1, \\xhat) \\le S(x_1, x_2) \\le S(\\xhat, x_2)，由x_1、x_2、\\xhat的任意性知结论成立。 Copyright © Avanti 2020 all right reserved，powered by Gitbook文件最后修改时间： 2021-06-19 10:20:29 "},"posts/matrix/derivative.html":{"url":"posts/matrix/derivative.html","title":"导数","keywords":"","body":"　　标量、向量、矩阵间的求导共有9种可能，其中\\partial \\text{scalar} / \\partial \\text{scalar}就是我们熟悉的单变量微积分，\\partial \\text{vector} / \\partial \\text{matrix}、\\partial \\text{matrix} / \\partial \\text{vector}、\\partial \\text{matrix} / \\partial \\text{matrix}会涉及高阶张量，处理更为麻烦，因此本文只考虑剩下的5种情形。 　　设\\uv \\in \\Rbb^l，\\Uv \\in \\Rbb^{m \\times n}，则向量、矩阵对标量求导的定义为 \\begin{align*} \\frac{\\partial \\uv}{\\partial x} \\triangleq \\begin{bmatrix} \\frac{\\partial u_1}{\\partial x} \\\\ \\frac{\\partial u_2}{\\partial x} \\\\ \\vdots \\\\ \\frac{\\partial u_l}{\\partial x} \\end{bmatrix}, \\quad \\frac{\\partial \\Uv}{\\partial x} \\triangleq \\begin{bmatrix} \\frac{\\partial u_{11}}{\\partial x} & \\frac{\\partial u_{12}}{\\partial x} & \\ldots & \\frac{\\partial u_{1n}}{\\partial x} \\\\ \\frac{\\partial u_{21}}{\\partial x} & \\frac{\\partial u_{22}}{\\partial x} & \\ldots & \\frac{\\partial u_{2n}}{\\partial x} \\\\ \\vdots & \\vdots & \\ddots & \\vdots \\\\ \\frac{\\partial u_{m1}}{\\partial x} & \\frac{\\partial u_{m2}}{\\partial x} & \\ldots & \\frac{\\partial u_{mn}}{\\partial x} \\end{bmatrix} \\end{align*} 设\\xv \\in \\Rbb^l，\\Xv \\in \\Rbb^{m \\times n}，则标量对向量、矩阵求导的定义为 \\begin{align*} \\frac{\\partial u}{\\partial \\xv} \\triangleq \\begin{bmatrix} \\frac{\\partial u}{\\partial x_1} & \\frac{\\partial u}{\\partial x_2} & \\ldots & \\frac{\\partial u}{\\partial x_l} \\end{bmatrix}, \\quad \\frac{\\partial u}{\\partial \\Xv} \\triangleq \\begin{bmatrix} \\frac{\\partial u}{\\partial x_{11}} & \\frac{\\partial u}{\\partial x_{21}} & \\ldots & \\frac{\\partial u}{\\partial x_{m1}} \\\\ \\frac{\\partial u}{\\partial x_{12}} & \\frac{\\partial u}{\\partial x_{22}} & \\ldots & \\frac{\\partial u}{\\partial x_{m2}} \\\\ \\vdots & \\vdots & \\ddots & \\vdots \\\\ \\frac{\\partial u}{\\partial x_{1n}} & \\frac{\\partial u}{\\partial x_{2n}} & \\ldots & \\frac{\\partial u}{\\partial x_{mn}} \\end{bmatrix} \\end{align*} 即向量、矩阵对标量求导的结果与分子尺寸相同，标量对向量、矩阵求导的结果与分母的转置尺寸相同。向量对向量求导的定义为雅可比矩阵： \\begin{align*} \\frac{\\partial \\uv}{\\partial \\xv} \\triangleq \\begin{bmatrix} \\frac{\\partial u_1}{\\partial x_1} & \\frac{\\partial u_1}{\\partial x_2} & \\ldots & \\frac{\\partial u_1}{\\partial x_l} \\\\ \\frac{\\partial u_2}{\\partial x_1} & \\frac{\\partial u_2}{\\partial x_2} & \\ldots & \\frac{\\partial u_2}{\\partial x_l} \\\\ \\vdots & \\vdots & \\ddots & \\vdots \\\\ \\frac{\\partial u_l}{\\partial x_1} & \\frac{\\partial u_l}{\\partial x_2} & \\ldots & \\frac{\\partial u_l}{\\partial x_l} \\end{bmatrix} \\end{align*} 即行数与分子尺寸相同、列数与分母尺寸相同。 　　以上即为分子布局，其好处是链式法则跟单变量微积分中的顺序一样，坏处是计算标量值函数f(\\xv)关于向量变量\\xv的梯度时要多做一个转置：\\nabla f = (\\frac{\\partial f}{\\partial \\xv})^\\top，否则梯度下降优化变量和梯度没法直接相减。分母布局的结果均是分子布局的转置，好处就是算梯度时不用做转置，坏处就是链式法则的顺序要完全反过来。 基本结果 　　以下结果根据定义和单变量微积分的求导法则都是显然的。 　　单变量微积分中常量的导数为零 \\begin{align*} \\frac{\\partial a}{\\partial x} = 0 \\end{align*} 类似的这里有 \\begin{align*} \\frac{\\partial \\av}{\\partial x} = \\zerov, \\quad \\frac{\\partial a}{\\partial \\xv} = \\zerov^\\top, \\quad \\frac{\\partial \\av}{\\partial \\xv} = \\zerov, \\quad \\frac{\\partial \\Av}{\\partial x} = \\zerov, \\quad \\frac{\\partial a}{\\partial \\Xv} = \\zerov^\\top \\end{align*} 　　单变量微积分中常数标量乘的求导法则为 \\begin{align*} \\frac{\\partial (a u)}{\\partial x} = a \\frac{\\partial u}{\\partial x} \\end{align*} 类似的这里有 \\begin{align*} \\frac{\\partial (a \\uv)}{\\partial x} = a \\frac{\\partial \\uv}{\\partial x}, \\quad \\frac{\\partial (a u)}{\\partial \\xv} = a \\frac{\\partial u}{\\partial \\xv}, \\quad \\frac{\\partial (a \\uv)}{\\partial \\xv} = a \\frac{\\partial \\uv}{\\partial \\xv}, \\quad \\frac{\\partial (a \\Uv)}{\\partial x} = a \\frac{\\partial \\Uv}{\\partial x}, \\quad \\frac{\\partial (a u)}{\\partial \\Xv} = a \\frac{\\partial u}{\\partial \\Xv} \\end{align*} 　　单变量微积分中加法的求导法则为 \\begin{align*} \\frac{\\partial (u+v)}{\\partial x} = \\frac{\\partial u}{\\partial x} + \\frac{\\partial v}{\\partial x} \\end{align*} 类似的这里有 \\begin{align*} & \\frac{\\partial (\\uv + \\vv)}{\\partial x} = \\frac{\\partial \\uv}{\\partial x} + \\frac{\\partial \\vv}{\\partial x}, \\quad \\frac{\\partial (u+v)}{\\partial \\xv} = \\frac{\\partial u}{\\partial \\xv} + \\frac{\\partial v}{\\partial \\xv}, \\quad \\frac{\\partial (\\uv + \\vv)}{\\partial \\xv} = \\frac{\\partial \\uv}{\\partial \\xv} + \\frac{\\partial \\vv}{\\partial \\xv} \\\\ & \\frac{\\partial (\\Uv + \\Vv)}{\\partial x} = \\frac{\\partial \\Uv}{\\partial x} + \\frac{\\partial \\Vv}{\\partial x}, \\quad \\frac{\\partial (u + v)}{\\partial \\Xv} = \\frac{\\partial u}{\\partial \\Xv} + \\frac{\\partial v}{\\partial \\Xv} \\end{align*} 　　单变量微积分中乘法的求导法则为 \\begin{align*} \\frac{\\partial (uv)}{\\partial x} = \\frac{\\partial u}{\\partial x} v + u \\frac{\\partial v}{\\partial x} \\end{align*} 类似的这里有 \\begin{align*} & \\frac{\\partial (\\uv \\vv)}{\\partial x} = \\frac{\\partial \\uv}{\\partial x} \\vv + \\uv \\frac{\\partial \\vv}{\\partial x}, \\quad \\frac{\\partial (uv)}{\\partial \\xv} = \\frac{\\partial u}{\\partial \\xv} v + u \\frac{\\partial v}{\\partial \\xv} \\\\ & \\frac{\\partial (\\Uv \\Vv)}{\\partial x} = \\frac{\\partial \\Uv}{\\partial x} \\Vv + \\Uv \\frac{\\partial \\Vv}{\\partial x}, \\quad \\frac{\\partial (uv)}{\\partial \\Xv} = \\frac{\\partial u}{\\partial \\Xv} v + u \\frac{\\partial v}{\\partial \\Xv} \\end{align*} 其中第二行是因为 \\begin{align*} \\left[ \\frac{\\partial (\\Uv \\Vv)}{\\partial x} \\right]_{ij} & = \\frac{\\partial (\\sum_k u_{ik} v_{kj})}{\\partial x} = \\sum_k \\frac{\\partial u_{ik}}{\\partial x} v_{kj} + \\sum_k u_{ik} \\frac{\\partial v_{kj}}{\\partial x} = \\left[ \\frac{\\partial \\Uv}{\\partial x} \\Vv \\right]_{ij} + \\left[ \\Uv \\frac{\\partial \\Vv}{\\partial x} \\right]_{ij} \\\\ \\left[ \\frac{\\partial (uv)}{\\partial \\Xv} \\right]_{ij} & = \\frac{\\partial (uv)}{\\partial x_{ji}} = \\frac{\\partial u}{\\partial x_{ji}} v + u \\frac{\\partial v}{\\partial x_{ji}} = \\left[ \\frac{\\partial u}{\\partial \\Xv} \\right]_{ij} v + u \\left[ \\frac{\\partial v}{\\partial \\Xv} \\right]_{ij} \\end{align*} 第一行可看作第二行的特例。\\partial (\\uv \\vv) / \\partial \\xv有两种可能，一是\\uv \\vv为标量，即两者的内积，这里暂且不表，后文再讲；二是\\uv \\vv为矩阵，这属于我们不考虑的\\partial \\text{matrix} / \\partial \\text{vector}情形。 　　单变量微积分中有\\partial x / \\partial x = 1，类似的这里有 \\begin{align*} \\frac{\\partial x_i}{\\partial \\xv} = \\ev_i^\\top, \\quad \\frac{\\partial \\xv}{\\partial x_i} = \\ev_i, \\quad \\frac{\\partial \\xv}{\\partial \\xv} = \\Iv, \\quad \\frac{\\partial x_{ij}}{\\partial \\Xv} = \\Ev_{ji}, \\quad \\frac{\\partial \\Xv}{\\partial x_{ij}} = \\Ev_{ij} \\end{align*} 其中\\Ev_{ij}是(i,j)处为1其余为0的矩阵。 　　单变量微积分中的链式法则为 \\begin{align*} \\frac{\\partial g(u)}{\\partial x} = \\frac{\\partial g(u)}{\\partial u} \\frac{\\partial u}{\\partial x} \\end{align*} 类似的， 只涉及向量：设\\xv \\in \\Rbb^n，\\uv = \\uv(\\xv) \\in \\Rbb^m，\\gv: \\Rbb^m \\mapsto \\Rbb^l，则 \\begin{align*} \\underbrace{\\frac{\\partial \\gv(\\uv)}{\\partial \\xv}}_{l \\times n} = \\underbrace{\\frac{\\partial \\gv(\\uv)}{\\partial \\uv}}_{l \\times m} \\underbrace{\\frac{\\partial \\uv}{\\partial \\xv}}_{m \\times n} \\end{align*} 这是因为 \\begin{align*} \\left[ \\frac{\\partial \\gv(\\uv)}{\\partial \\xv} \\right]_{ij} & = \\frac{\\partial [\\gv(\\uv)]_i}{\\partial x_j} = \\sum_{k \\in [m]} \\frac{\\partial [\\gv(\\uv)]_i}{\\partial u_k} \\frac{\\partial u_k}{\\partial x_j} = \\frac{\\partial [\\gv(\\uv)]_i}{\\partial \\uv} \\frac{\\partial \\uv}{\\partial x_j} \\\\ & = \\left[ \\frac{\\partial \\gv(\\uv)}{\\partial \\uv} \\right]\\_{i,:} \\left[ \\frac{\\partial \\uv}{\\partial \\xv} \\right]\\_{:,j} = \\left[ \\frac{\\partial \\gv(\\uv)}{\\partial \\uv} \\frac{\\partial \\uv}{\\partial \\xv} \\right]\\_{i,j} \\end{align*} 注意若n = m = l = 1，就退化成了单变量的链式法则。 自变量是矩阵：设u = u(\\Xv)，g: \\Rbb \\mapsto \\Rbb，则 \\begin{align*} \\frac{\\partial g(u)}{\\partial \\Xv} = \\frac{\\partial g(u)}{\\partial u} \\frac{\\partial u}{\\partial \\Xv} \\end{align*} 这是因为 \\begin{align*} \\left[ \\frac{\\partial g(u)}{\\partial \\Xv} \\right]_{ij} & = \\frac{\\partial g(u)}{\\partial x_{ji}} = \\frac{\\partial g(u)}{\\partial u} \\frac{\\partial u}{\\partial x_{ji}} = \\frac{\\partial g(u)}{\\partial u} \\left[ \\frac{\\partial u}{\\partial \\Xv} \\right]_{ij} \\end{align*} 中间变量是矩阵：设\\Uv = \\Uv(x) \\in \\Rbb^{m \\times n}，g: \\Rbb^{m \\times n} \\mapsto \\Rbb，则 \\begin{align} \\label{eq: chain-matrix} \\class{blue}{\\frac{\\partial g(\\Uv)}{\\partial x}} = \\sum_p \\sum_q \\frac{\\partial g(\\Uv)}{\\partial u_{pq}} \\frac{\\partial u_{pq}}{\\partial x} = \\sum_q \\sum_p \\left[ \\frac{\\partial g(\\Uv)}{\\partial \\Uv} \\right]_{qp} \\left[ \\frac{\\partial \\Uv}{\\partial x} \\right]_{pq} = \\class{blue}{\\tr \\left( \\frac{\\partial g(\\Uv)}{\\partial \\Uv} \\frac{\\partial \\Uv}{\\partial x} \\right)} \\end{align} 向量对标量求导 　　矩阵和向量的乘积是向量，若\\Av与\\xv无关，易知有 \\begin{align*} & \\left[ \\frac{\\partial (\\Av \\uv)}{\\partial x} \\right]_{i} = \\frac{\\partial [\\Av \\uv]_i}{\\partial x} = \\frac{\\partial (\\sum_k a_{ik} u_k)}{\\partial x} = \\sum_k a_{ik} \\frac{\\partial u_k}{\\partial x} = \\left[ \\Av \\frac{\\partial \\uv}{\\partial x} \\right]_i \\Longrightarrow \\class{blue}{\\frac{\\partial (\\Av \\uv)}{\\partial x} = \\Av \\frac{\\partial \\uv}{\\partial x}} \\\\ & \\class{blue}{\\frac{\\partial (\\uv^\\top \\Av)}{\\partial x}} = \\left[ \\frac{\\partial (\\Av^\\top \\uv)}{\\partial x} \\right]^\\top = \\left[ \\Av^\\top \\frac{\\partial \\uv}{\\partial x} \\right]^\\top = \\class{blue}{\\frac{\\partial \\uv^\\top}{\\partial x} \\Av} \\end{align*} 　　向量的外积也是向量，记\\uv = [u_1(x); u_2(x); u_3(x)]，\\vv = [v_1(x); v_2(x); v_3(x)]，则 \\begin{align*} \\uv \\times \\vv = \\begin{bmatrix} u_2 v_3 - u_3 v_2 \\\\ u_3 v_1 - u_1 v_3 \\\\ u_1 v_2 - u_2 v_1 \\end{bmatrix} \\end{align*} 于是 \\begin{align*} \\class{blue}{\\frac{\\partial (\\uv \\times \\vv)}{\\partial x}} & = \\begin{bmatrix} \\frac{\\partial u_2}{\\partial x} v_3 - \\frac{\\partial u_3}{\\partial x} v_2 + u_2 \\frac{\\partial v_3}{\\partial x} - u_3 \\frac{\\partial v_2}{\\partial x} \\\\ \\frac{\\partial u_3}{\\partial x} v_1 - \\frac{\\partial u_1}{\\partial x} v_3 + u_3 \\frac{\\partial v_1}{\\partial x} - u_1 \\frac{\\partial v_3}{\\partial x} \\\\ \\frac{\\partial u_1}{\\partial x} v_2 - \\frac{\\partial u_2}{\\partial x} v_1 + u_1 \\frac{\\partial v_2}{\\partial x} - u_2 \\frac{\\partial v_1}{\\partial x} \\\\ \\end{bmatrix} = \\class{blue}{\\left( \\frac{\\partial \\uv}{\\partial x} \\right) \\times \\vv + \\uv \\times \\frac{\\partial \\vv}{\\partial x}} \\end{align*} 标量对向量求导 　　二次型是标量，设\\Av与\\xv无关，易知有 \\begin{align*} \\left[ \\frac{\\partial (\\uv^\\top \\Av \\vv)}{\\partial \\xv} \\right]_i & = \\frac{\\partial (\\uv^\\top \\Av \\vv)}{\\partial x_i} = \\frac{\\partial (\\sum_j \\sum_k u_j a_{jk} v_k)}{\\partial x_i} = \\sum_j \\sum_k u_j a_{jk} \\frac{\\partial v_k}{\\partial x_i} + \\sum_j \\sum_k \\frac{\\partial u_j}{\\partial x_i} a_{jk} v_k \\\\ & = \\uv^\\top \\Av \\frac{\\partial \\vv}{\\partial x_i} + \\vv^\\top \\Av^\\top \\frac{\\partial \\uv}{\\partial x_i} = \\left[ \\uv^\\top \\Av \\frac{\\partial \\vv}{\\partial \\xv} \\right]_i + \\left[ \\vv^\\top \\Av^\\top \\frac{\\partial \\uv}{\\partial \\xv} \\right]_i \\\\ & \\Longrightarrow \\class{blue}{\\frac{\\partial (\\uv^\\top \\Av \\vv)}{\\partial \\xv} = \\uv^\\top \\Av \\frac{\\partial \\vv}{\\partial \\xv} + \\vv^\\top \\Av^\\top \\frac{\\partial \\uv}{\\partial \\xv}} \\end{align*} 　　特别的， 取\\Av = \\Iv，则 \\begin{align*} \\frac{\\partial (\\uv^\\top \\vv)}{\\partial \\xv} = \\uv^\\top \\frac{\\partial \\vv}{\\partial \\xv} + \\vv^\\top \\frac{\\partial \\uv}{\\partial \\xv} \\end{align*} 进一步若\\uv = \\av与\\xv无关，则 \\begin{align*} \\frac{\\partial (\\av^\\top \\vv)}{\\partial \\xv} = \\av^\\top \\frac{\\partial \\vv}{\\partial \\xv}, \\quad \\frac{\\partial (\\av^\\top \\xv)}{\\partial \\xv} = \\av^\\top \\frac{\\partial \\xv}{\\partial \\xv} = \\av^\\top, \\quad \\frac{\\partial (\\bv^\\top \\Av \\xv)}{\\partial \\xv} = \\bv^\\top \\Av \\end{align*} 取\\uv = \\vv = \\xv，则 \\begin{align*} \\frac{\\partial (\\xv^\\top \\Av \\xv)}{\\partial \\xv} = \\xv^\\top \\Av \\frac{\\partial \\xv}{\\partial \\xv} + \\xv^\\top \\Av^\\top \\frac{\\partial \\xv}{\\partial \\xv} = \\xv^\\top (\\Av + \\Av^\\top) \\end{align*} 进一步若\\Av = \\Iv，则 \\begin{align*} \\frac{\\partial (\\xv^\\top \\xv)}{\\partial \\xv} = \\frac{\\partial \\|\\xv\\|^2}{\\partial \\xv} = 2 \\xv^\\top \\end{align*} 若\\Av = \\bv \\av^\\top，则 \\begin{align*} \\frac{\\partial (\\xv^\\top \\bv \\av^\\top \\xv)}{\\partial \\xv} = \\frac{\\partial (\\av^\\top \\xv \\xv^\\top \\bv)}{\\partial \\xv} = \\xv^\\top (\\av \\bv^\\top + \\bv \\av^\\top) \\end{align*} 更一般的有 \\begin{align*} \\frac{\\partial [(\\Av \\xv + \\bv)^\\top \\Cv (\\Dv \\xv + \\ev)]}{\\partial \\xv} & = \\frac{\\partial (\\xv^\\top \\Av^\\top \\Cv \\Dv \\xv + \\bv^\\top \\Cv \\Dv \\xv + \\xv^\\top \\Av^\\top \\Cv \\ev + \\bv^\\top \\ev)}{\\partial \\xv} \\\\ & = \\xv^\\top (\\Av^\\top \\Cv \\Dv + \\Dv^\\top \\Cv^\\top \\Av) + \\bv^\\top \\Cv \\Dv + \\ev^\\top \\Cv^\\top \\Av \\\\\\\\ & = (\\Dv \\xv + \\ev)^\\top \\Cv^\\top \\Av + (\\Av \\xv + \\bv)^\\top \\Cv \\Dv \\end{align*} 　　范数也是标量，若\\av与\\xv无关，则 \\begin{align} \\label{eq: norm} \\left[ \\frac{\\partial \\| \\xv - \\av \\|}{\\partial \\xv} \\right]_i & = \\frac{\\partial \\| \\xv - \\av \\|}{\\partial x_i} = \\frac{\\partial \\sqrt{\\sum_j (x_j - a_j)^2}}{\\partial x_i} = \\frac{1}{2} \\frac{2 (x_i - a_i)}{\\sqrt{\\sum_j (x_j - a_j)^2}} = \\frac{x_i - a_i}{\\| \\xv - \\av \\|} \\\\ & \\Longrightarrow \\class{blue}{\\frac{\\partial \\| \\xv - \\av \\|}{\\partial \\xv} = \\frac{(\\xv - \\av)^\\top}{\\| \\xv - \\av \\|}} \\nonumber \\end{align} 向量对向量求导 　　若\\Av与\\xv无关，易知有 \\begin{align*} & \\left[ \\frac{\\partial (\\Av \\uv)}{\\partial \\xv} \\right]_{ij} = \\frac{\\partial [\\Av \\uv]_i}{\\partial x_j} = \\frac{\\partial (\\sum_k a_{ik} u_k)}{\\partial x_j} = \\sum_k a_{ik} \\frac{\\partial u_k}{\\partial x_j} = \\left[ \\Av \\frac{\\partial \\uv}{\\partial \\xv} \\right]_{ij} \\Longrightarrow \\class{blue}{\\frac{\\partial (\\Av \\uv)}{\\partial \\xv} = \\Av \\frac{\\partial \\uv}{\\partial \\xv}} \\end{align*} 特别的，若\\uv = \\xv，则 \\begin{align*} \\frac{\\partial (\\Av \\xv)}{\\partial \\xv} = \\Av \\frac{\\partial \\xv}{\\partial \\xv} = \\Av \\end{align*} 　　若v = v(\\xv)，则 \\begin{align*} \\left[ \\frac{\\partial (v \\uv)}{\\partial \\xv} \\right]_{ij} = \\frac{\\partial (v u_i)}{\\partial x_j} = v \\frac{\\partial u_i}{\\partial x_j} + u_i \\frac{\\partial v}{\\partial x_j} = v \\left[ \\frac{\\partial \\uv}{\\partial \\xv} \\right]_{ij} + \\left[ \\uv \\frac{\\partial v}{\\partial \\xv} \\right]_{ij} \\Longrightarrow \\class{blue}{\\frac{\\partial (v \\uv)}{\\partial \\xv} = v \\frac{\\partial \\uv}{\\partial \\xv} + \\uv \\frac{\\partial v}{\\partial \\xv}} \\end{align*} 注意第一项是标量乘以雅可比矩阵，第二项是列向量乘以行向量。 　　若\\av与\\xv无关，结合式(\\ref{eq: norm})可得 \\begin{align*} \\left[ \\frac{\\partial}{\\partial \\xv} \\frac{\\xv - \\av}{\\| \\xv - \\av \\|} \\right]_{ij} & = \\frac{\\partial}{\\partial x_j} \\frac{x_i - a_i}{\\| \\xv - \\av \\|} = \\frac{\\delta_{ij} \\|\\xv - \\av\\|}{\\| \\xv - \\av \\|^2} - \\frac{x_i - a_i}{\\| \\xv - \\av \\|^2} \\frac{\\partial \\| \\xv - \\av \\|}{\\partial x_j} \\\\ & = \\frac{\\delta_{ij}}{\\| \\xv - \\av \\|} - \\frac{x_i - a_i}{\\| \\xv - \\av \\|^2} \\frac{x_j - a_j}{\\| \\xv - \\av \\|} \\\\ & \\Longrightarrow \\class{blue}{\\frac{\\partial}{\\partial \\xv} \\frac{\\xv - \\av}{\\| \\xv - \\av \\|} = \\frac{\\Iv}{\\| \\xv - \\av \\|} - \\frac{(\\xv - \\av)(\\xv - \\av)^\\top}{\\| \\xv - \\av \\|^3}} \\end{align*} 矩阵对标量求导 　　若u = u(x)，\\Vv = \\Vv(x)，则 \\begin{align*} \\left[ \\frac{\\partial (u \\Vv)}{\\partial x} \\right]_{ij} = \\frac{\\partial (u v_{ij})}{\\partial x} = \\frac{\\partial u}{\\partial x} v_{ij} + u \\frac{\\partial v_{ij}}{\\partial x} = \\frac{\\partial u}{\\partial x} \\left[ \\Vv \\right]_{ij} + u \\left[ \\frac{\\partial \\Vv}{\\partial x} \\right]_{ij} \\Longrightarrow \\class{blue}{\\frac{\\partial (u \\Vv)}{\\partial x} = \\frac{\\partial u}{\\partial x} \\Vv + u \\frac{\\partial \\Vv}{\\partial x}} \\end{align*} 　　若乘积求导法则中的\\Uv或\\Vv可继续分解为x相关项的乘积，例如\\Vv \\leftarrow \\Vv \\Wv，则 \\begin{align} \\label{eq: product} \\class{blue}{\\frac{\\partial (\\Uv \\Vv \\Wv)}{\\partial x}} = \\frac{\\partial \\Uv}{\\partial x} \\Vv \\Wv + \\Uv \\frac{\\partial (\\Vv \\Wv)}{\\partial x} = \\frac{\\partial \\Uv}{\\partial x} \\Vv \\Wv + \\Uv \\left( \\frac{\\partial \\Vv}{\\partial x} \\Wv + \\Vv \\frac{\\partial \\Wv}{\\partial x} \\right) = \\class{blue}{\\frac{\\partial \\Uv}{\\partial x} \\Vv \\Wv + \\Uv \\frac{\\partial \\Vv}{\\partial x} \\Wv + \\Uv \\Vv \\frac{\\partial \\Wv}{\\partial x}} \\end{align} 由此可知若\\Av、\\Bv与x无关，则 \\begin{align*} \\frac{\\partial (\\Av \\Uv \\Bv)}{\\partial x} = \\Av \\frac{\\partial \\Uv}{\\partial x} \\Bv \\end{align*} 当\\Uv为方阵、n为正整数时有 \\begin{align} \\label{eq: power} \\class{blue}{\\frac{\\partial \\Uv^n}{\\partial x}} = \\Uv^{n-1} \\frac{\\partial \\Uv}{\\partial x} + \\Uv^{n-2} \\frac{\\partial \\Uv}{\\partial x} \\Uv + \\cdots + \\Uv \\frac{\\partial \\Uv}{\\partial x} \\Uv^{n-2} + \\frac{\\partial \\Uv}{\\partial x} \\Uv^{n-1} = \\class{blue}{\\sum_{i \\in [n]} \\Uv^{i-1} \\frac{\\partial \\Uv}{\\partial x} \\Uv^{n-i}} \\end{align} 　　令乘积求导法则中的\\Vv = \\Uv^{-1}可得 \\begin{align} \\label{eq: inverse} \\zerov = \\frac{\\partial \\Iv}{\\partial x} = \\frac{\\partial (\\Uv \\Uv^{-1})}{\\partial x} = \\Uv \\frac{\\partial \\Uv^{-1}}{\\partial x} + \\frac{\\partial \\Uv}{\\partial x} \\Uv^{-1} \\Longrightarrow \\class{blue}{\\frac{\\partial \\Uv^{-1}}{\\partial x} = - \\Uv^{-1} \\frac{\\partial \\Uv}{\\partial x} \\Uv^{-1}} \\end{align} 由此可知 \\begin{align*} \\class{blue}{\\frac{\\partial [\\Xv^{-1}]_{kl}}{\\partial x_{ij}}} & = \\tr \\left( \\frac{\\partial [\\Xv^{-1}]_{kl}}{\\partial \\Xv^{-1}} \\frac{\\partial \\Xv^{-1}}{\\partial x_{ij}} \\right) = - \\tr \\left( \\Ev_{lk} \\Xv^{-1} \\frac{\\partial \\Xv}{\\partial x_{ij}} \\Xv^{-1} \\right) = - \\tr ( \\Xv^{-1} \\Ev_{lk} \\Xv^{-1} \\Ev_{ij} ) \\\\ & = - [\\Xv^{-1} \\Ev_{lk} \\Xv^{-1}]_{ji} = - \\sum_p \\sum_q [\\Xv^{-1}]_{jp} [\\Ev_{lk}]_{pq} [\\Xv^{-1}]_{qi} = \\class{blue}{- [\\Xv^{-1}]_{jl} [\\Xv^{-1}]_{ki}} \\end{align*} 结合式(\\ref{eq: product})还可得海森矩阵 \\begin{align*} \\class{blue}{\\frac{\\partial^2 \\Uv^{-1}}{\\partial x \\partial y}} & = \\frac{\\partial}{\\partial y} \\left( - \\Uv^{-1} \\frac{\\partial \\Uv}{\\partial x} \\Uv^{-1} \\right) = - \\frac{\\partial \\Uv^{-1}}{\\partial y} \\frac{\\partial \\Uv}{\\partial x} \\Uv^{-1} - \\Uv^{-1} \\frac{\\partial^2 \\Uv}{\\partial x \\partial y} \\Uv^{-1} - \\Uv^{-1} \\frac{\\partial \\Uv}{\\partial x} \\frac{\\partial \\Uv^{-1}}{\\partial y} \\\\ & = \\Uv^{-1} \\frac{\\partial \\Uv}{\\partial y} \\Uv^{-1} \\frac{\\partial \\Uv}{\\partial x} \\Uv^{-1} - \\Uv^{-1} \\frac{\\partial^2 \\Uv}{\\partial x \\partial y} \\Uv^{-1} + \\Uv^{-1} \\frac{\\partial \\Uv}{\\partial x} \\Uv^{-1} \\frac{\\partial \\Uv}{\\partial y} \\Uv^{-1} \\\\ & = \\class{blue}{\\Uv^{-1} \\left( \\frac{\\partial \\Uv}{\\partial y} \\Uv^{-1} \\frac{\\partial \\Uv}{\\partial x} - \\frac{\\partial^2 \\Uv}{\\partial x \\partial y} + \\frac{\\partial \\Uv}{\\partial x} \\Uv^{-1} \\frac{\\partial \\Uv}{\\partial y} \\right) \\Uv^{-1}} \\end{align*} 　　矩阵除了常规的乘积外，还有克罗内克积和哈达玛积。设\\Uv \\in \\Rbb^{m \\times n}，\\Vv \\in \\Rbb^{p \\times q}，则 \\begin{align*} \\class{blue}{\\frac{\\partial (\\Uv \\otimes \\Vv)}{\\partial x}} & = \\begin{bmatrix} \\frac{\\partial u_{11} \\Vv}{\\partial x} & \\frac{\\partial u_{12} \\Vv}{\\partial x} & \\cdots & \\frac{\\partial u_{1n} \\Vv}{\\partial x} \\\\ \\frac{\\partial u_{21} \\Vv}{\\partial x} & \\frac{\\partial u_{22} \\Vv}{\\partial x} & \\cdots & \\frac{\\partial u_{2n} \\Vv}{\\partial x} \\\\ \\vdots & \\vdots & \\ddots & \\vdots \\\\ \\frac{\\partial u_{m1} \\Vv}{\\partial x} & \\frac{\\partial u_{m2} \\Vv}{\\partial x} & \\cdots & \\frac{\\partial u_{mn} \\Vv}{\\partial x} \\\\ \\end{bmatrix} \\\\ & = \\begin{bmatrix} \\frac{\\partial u_{11}}{\\partial x} \\Vv + u_{11} \\frac{\\partial \\Vv}{\\partial x} & \\frac{\\partial u_{12}}{\\partial x} \\Vv + u_{12} \\frac{\\partial \\Vv}{\\partial x} & \\cdots & \\frac{\\partial u_{1n}}{\\partial x} \\Vv + u_{1n} \\frac{\\partial \\Vv}{\\partial x} \\\\ \\frac{\\partial u_{21}}{\\partial x} \\Vv + u_{21} \\frac{\\partial \\Vv}{\\partial x} & \\frac{\\partial u_{22}}{\\partial x} \\Vv + u_{22} \\frac{\\partial \\Vv}{\\partial x} & \\cdots & \\frac{\\partial u_{2n}}{\\partial x} \\Vv + u_{2n} \\frac{\\partial \\Vv}{\\partial x} \\\\ \\vdots & \\vdots & \\ddots & \\vdots \\\\ \\frac{\\partial u_{m1}}{\\partial x} \\Vv + u_{m1} \\frac{\\partial \\Vv}{\\partial x} & \\frac{\\partial u_{m2}}{\\partial x} \\Vv + u_{m2} \\frac{\\partial \\Vv}{\\partial x} & \\cdots & \\frac{\\partial u_{mn}}{\\partial x} \\Vv + u_{mn} \\frac{\\partial \\Vv}{\\partial x} \\\\ \\end{bmatrix} \\\\ & = \\begin{bmatrix} \\frac{\\partial u_{11}}{\\partial x} \\Vv & \\frac{\\partial u_{12}}{\\partial x} \\Vv & \\cdots & \\frac{\\partial u_{1n}}{\\partial x} \\Vv \\\\ \\frac{\\partial u_{21}}{\\partial x} \\Vv & \\frac{\\partial u_{22}}{\\partial x} \\Vv & \\cdots & \\frac{\\partial u_{2n}}{\\partial x} \\Vv \\\\ \\vdots & \\vdots & \\ddots & \\vdots \\\\ \\frac{\\partial u_{m1}}{\\partial x} \\Vv & \\frac{\\partial u_{m2}}{\\partial x} \\Vv & \\cdots & \\frac{\\partial u_{mn}}{\\partial x} \\Vv \\\\ \\end{bmatrix} + \\begin{bmatrix} u_{11} \\frac{\\partial \\Vv}{\\partial x} & u_{12} \\frac{\\partial \\Vv}{\\partial x} & \\cdots & u_{1n} \\frac{\\partial \\Vv}{\\partial x} \\\\ u_{21} \\frac{\\partial \\Vv}{\\partial x} & u_{22} \\frac{\\partial \\Vv}{\\partial x} & \\cdots & u_{2n} \\frac{\\partial \\Vv}{\\partial x} \\\\ \\vdots & \\vdots & \\ddots & \\vdots \\\\ u_{m1} \\frac{\\partial \\Vv}{\\partial x} & u_{m2} \\frac{\\partial \\Vv}{\\partial x} & \\cdots & u_{mn} \\frac{\\partial \\Vv}{\\partial x} \\\\ \\end{bmatrix} \\\\ & = \\class{blue}{\\frac{\\partial \\Uv}{\\partial x} \\otimes \\Vv + \\Uv \\otimes \\frac{\\partial \\Vv}{\\partial x}} \\end{align*} 设\\Uv, \\Vv \\in \\Rbb^{m \\times n}，则 \\begin{align*} \\class{blue}{\\frac{\\partial (\\Uv \\odot \\Vv)}{\\partial x}} & = \\begin{bmatrix} \\frac{\\partial u_{11} v_{11}}{\\partial x} & \\frac{\\partial u_{12} v_{12}}{\\partial x} & \\cdots & \\frac{\\partial u_{1n} v_{1n}}{\\partial x} \\\\ \\frac{\\partial u_{21} v_{21}}{\\partial x} & \\frac{\\partial u_{22} v_{22}}{\\partial x} & \\cdots & \\frac{\\partial u_{2n} v_{2n}}{\\partial x} \\\\ \\vdots & \\vdots & \\ddots & \\vdots \\\\ \\frac{\\partial u_{m1} v_{m1}}{\\partial x} & \\frac{\\partial u_{m2} v_{m2}}{\\partial x} & \\cdots & \\frac{\\partial u_{mn} v_{mn}}{\\partial x} \\\\ \\end{bmatrix} \\\\ & = \\begin{bmatrix} \\frac{\\partial u_{11}}{\\partial x} v_{11} & \\frac{\\partial u_{12}}{\\partial x} v_{12} & \\cdots & \\frac{\\partial u_{1n}}{\\partial x} v_{1n} \\\\ \\frac{\\partial u_{21}}{\\partial x} v_{21} & \\frac{\\partial u_{22}}{\\partial x} v_{22} & \\cdots & \\frac{\\partial u_{2n}}{\\partial x} v_{2n} \\\\ \\vdots & \\vdots & \\ddots & \\vdots \\\\ \\frac{\\partial u_{m1}}{\\partial x} v_{m1} & \\frac{\\partial u_{m2}}{\\partial x} v_{m2} & \\cdots & \\frac{\\partial u_{mn}}{\\partial x} v_{mn} \\\\ \\end{bmatrix} + \\begin{bmatrix} u_{11} \\frac{\\partial v_{11}}{\\partial x} & u_{12} \\frac{\\partial v_{12}}{\\partial x} & \\cdots & u_{1n} \\frac{\\partial v_{1n}}{\\partial x} \\\\ u_{21} \\frac{\\partial v_{21}}{\\partial x} & u_{22} \\frac{\\partial v_{22}}{\\partial x} & \\cdots & u_{2n} \\frac{\\partial v_{2n}}{\\partial x} \\\\ \\vdots & \\vdots & \\ddots & \\vdots \\\\ u_{m1} \\frac{\\partial v_{m1}}{\\partial x} & u_{m2} \\frac{\\partial v_{m2}}{\\partial x} & \\cdots & u_{mn} \\frac{\\partial v_{mn}}{\\partial x} \\\\ \\end{bmatrix} \\\\ & = \\class{blue}{\\frac{\\partial \\Uv}{\\partial x} \\odot \\Vv + \\Uv \\odot \\frac{\\partial \\Vv}{\\partial x}} \\end{align*} 　　设多项式函数g(x) = a_0 + a_1 x + a_2 x^2 + a_3 x^3 + \\cdots，则g'(x) = a_1 + 2 a_2 x + 3 a_3 x^2 + \\cdots，若\\Av为与x无关的方阵，记 \\begin{align*} g (x \\Av) & = a_0 \\Iv + a_1 x \\Av + a_2 x^2 \\Av^2 + a_3 x^3 \\Av^3 + \\cdots \\\\ g' (x \\Av) & = a_1 \\Iv + 2 a_2 x \\Av + 3 a_3 x^2 \\Av^2 + \\cdots \\end{align*} 易知有 \\begin{align*} \\class{blue}{\\frac{\\partial g(x \\Av)}{\\partial x}} & = a_1 \\Av + 2 a_2 x \\Av^2 + 3 a_3 x^2 \\Av^3 + \\cdots \\\\ & = \\Av (a_1 \\Iv + 2 a_2 x \\Av + 3 a_3 x^2 \\Av^2 + \\cdots) = \\class{blue}{\\Av g' (x \\Av)} \\\\ & = (a_1 \\Iv + 2 a_2 x \\Av + 3 a_3 x^2 \\Av^2 + \\cdots) \\Av = \\class{blue}{g' (x \\Av) \\Av} \\end{align*} 对于e^x、\\ln x、\\sin x、\\cos x，上式依然适用，例如 \\begin{align*} \\frac{\\partial e^{x \\Av}}{\\partial x} = \\Av e^{x \\Av} = e^{x \\Av} \\Av \\end{align*} 标量对矩阵求导 　　矩阵常见的标量函数有迹和行列式，二次型可以归为迹来处理。 迹对矩阵求导 　　若a与\\Xv无关，\\Uv = \\Uv(\\Xv)，\\Vv = \\Vv(\\Xv)，则以下结论是显然的： \\begin{align*} \\frac{\\partial \\tr(\\Xv)}{\\partial \\Xv} = \\Iv, \\quad \\frac{\\partial \\tr(\\Uv+\\Vv)}{\\partial \\Xv} = \\frac{\\partial \\tr(\\Uv)}{\\partial \\Xv} + \\frac{\\partial \\tr(\\Vv)}{\\partial \\Xv}, \\quad \\frac{\\partial \\tr(a \\Uv)}{\\partial \\Xv} = a \\frac{\\partial \\tr(\\Uv)}{\\partial \\Xv} \\end{align*} 对于乘积有 \\begin{align*} \\left[ \\frac{\\partial \\tr(\\Uv \\Vv)}{\\partial \\Xv} \\right]_{ij} & = \\class{blue}{\\frac{\\partial \\tr(\\Uv \\Vv)}{\\partial x_{ji}}} = \\frac{\\partial (\\sum_p \\sum_q u_{pq} v_{qp})}{\\partial x_{ji}} = \\sum_p \\sum_q \\left( \\frac{\\partial u_{pq}}{\\partial x_{ji}} v_{qp} + u_{pq} \\frac{\\partial v_{qp}}{\\partial x_{ji}} \\right) \\\\ & = \\class{blue}{\\tr \\left( \\frac{\\partial \\Uv}{\\partial x_{ji}} \\Vv \\right) + \\tr \\left( \\Uv \\frac{\\partial \\Vv}{\\partial x_{ji}} \\right)} = \\tr \\left( \\frac{\\partial (\\Uv \\Vv)}{\\partial x_{ji}} \\right) \\end{align*} 由此可知迹和求导的顺序可以交换。特别的， 取\\Uv = \\Bv \\Av与\\Xv无关，\\Vv = \\Xv，则 \\begin{align*} \\left[ \\frac{\\partial \\tr(\\Bv \\Av \\Xv)}{\\partial \\Xv} \\right]_{ij} = \\tr \\left( \\Bv \\Av \\frac{\\partial \\Xv}{\\partial x_{ji}} \\right) = \\tr ( \\Bv \\Av \\Ev_{ji} ) = [\\Bv \\Av]_{ij} \\Longrightarrow \\frac{\\partial \\tr(\\Bv \\Av \\Xv)}{\\partial \\Xv} = \\frac{\\partial \\tr(\\Av \\Xv \\Bv)}{\\partial \\Xv} = \\Bv \\Av \\end{align*} 取\\Uv = \\Bv \\Av与\\Xv无关，\\Vv = \\Xv^\\top，则 \\begin{align*} \\frac{\\partial \\tr(\\Bv \\Av \\Xv^\\top)}{\\partial \\Xv} = \\frac{\\partial \\tr(\\Xv \\Av^\\top \\Bv^\\top)}{\\partial \\Xv} = \\frac{\\partial \\tr(\\Av^\\top \\Bv^\\top \\Xv)}{\\partial \\Xv} = \\Av^\\top \\Bv^\\top \\end{align*} 取\\Uv = \\Av与\\Xv无关，\\Vv = \\Xv \\Xv^\\top，则 \\begin{align*} \\left[ \\frac{\\partial \\tr(\\Av \\Xv \\Xv^\\top)}{\\partial \\Xv} \\right]_{ij} & = \\tr \\left( \\Av \\frac{\\partial \\Xv \\Xv^\\top}{\\partial x_{ji}} \\right) = \\tr \\left( \\Av \\frac{\\partial \\Xv}{\\partial x_{ji}} \\Xv^\\top \\right) + \\tr \\left( \\Av \\Xv \\frac{\\partial \\Xv^\\top}{\\partial x_{ji}} \\right) \\\\ & = \\tr(\\Av \\Ev\\_{ji} \\Xv^\\top) + \\tr(\\Av \\Xv \\Ev\\_{ij}) \\\\\\\\ & = [\\Xv^\\top \\Av]\\_{ij} + [\\Av \\Xv]\\_{ji} \\end{align*} 从而 \\begin{align*} \\frac{\\partial \\tr(\\Av \\Xv \\Xv^\\top)}{\\partial \\Xv} = \\frac{\\partial \\tr(\\Xv^\\top \\Av \\Xv)}{\\partial \\Xv} = \\frac{\\partial \\tr(\\Xv \\Xv^\\top \\Av)}{\\partial \\Xv} = \\Xv^\\top \\Av + \\Xv^\\top \\Av^\\top = \\Xv^\\top (\\Av + \\Av^\\top) \\end{align*} 取\\Uv = \\Av与\\Xv无关，\\Vv = \\Xv^\\top \\Xv，则 \\begin{align*} \\left[ \\frac{\\partial \\tr(\\Av \\Xv^\\top \\Xv)}{\\partial \\Xv} \\right]_{ij} & = \\tr \\left( \\Av \\frac{\\partial \\Xv^\\top \\Xv}{\\partial x_{ji}} \\right) = \\tr \\left( \\Av \\frac{\\partial \\Xv^\\top}{\\partial x_{ji}} \\Xv \\right) + \\tr \\left( \\Av \\Xv^\\top \\frac{\\partial \\Xv}{\\partial x_{ji}} \\right) \\\\ & = \\tr(\\Av \\Ev\\_{ij} \\Xv) + \\tr(\\Av \\Xv^\\top \\Ev\\_{ji}) \\\\\\\\ & = [\\Xv \\Av]\\_{ji} + [\\Av \\Xv^\\top]\\_{ij} \\end{align*} 从而 \\begin{align*} \\frac{\\partial \\tr(\\Av \\Xv^\\top \\Xv)}{\\partial \\Xv} = \\frac{\\partial \\tr(\\Xv \\Av \\Xv^\\top)}{\\partial \\Xv} = \\frac{\\partial \\tr(\\Xv^\\top \\Xv \\Av)}{\\partial \\Xv} = (\\Av + \\Av^\\top) \\Xv^\\top \\end{align*} 取\\Uv = \\Bv \\Av与\\Xv无关，\\Vv = \\Xv^{-1}，结合式(\\ref{eq: inverse})可得 \\begin{align*} \\left[ \\frac{\\partial \\tr(\\Bv \\Av \\Xv^{-1})}{\\partial \\Xv} \\right]_{ij} & = \\tr \\left( \\Bv \\Av \\frac{\\partial \\Xv^{-1}}{\\partial x_{ji}} \\right) = \\tr \\left( - \\Bv \\Av \\Xv^{-1} \\frac{\\partial \\Xv}{\\partial x_{ji}} \\Xv^{-1} \\right) \\\\ & = - \\tr \\left( \\Xv^{-1} \\Bv \\Av \\Xv^{-1} \\Ev\\_{ji} \\right) = - [\\Xv^{-1} \\Bv \\Av \\Xv^{-1}]\\_{ij} \\\\\\\\ & \\Longrightarrow \\frac{\\partial \\tr(\\Bv \\Av \\Xv^{-1})}{\\partial \\Xv} = \\frac{\\partial \\tr(\\Av \\Xv^{-1} \\Bv)}{\\partial \\Xv} = - \\Xv^{-1} \\Bv \\Av \\Xv^{-1} \\end{align*} 取\\Uv = \\Iv，\\Vv = (\\Xv + \\Av)^{-1}，结合式(\\ref{eq: inverse})可得 \\begin{align*} \\left[ \\frac{\\partial \\tr(\\Xv + \\Av)^{-1}}{\\partial \\Xv} \\right]_{ij} & = \\tr \\left( \\frac{\\partial (\\Xv + \\Av)^{-1}}{\\partial x_{ji}} \\right) = - \\tr \\left( (\\Xv + \\Av)^{-1} \\frac{\\partial (\\Xv + \\Av)}{\\partial x_{ji}} (\\Xv + \\Av)^{-1} \\right) \\\\ & = - \\tr \\left( (\\Xv + \\Av)^{-1} (\\Xv + \\Av)^{-1} \\Ev\\_{ji} \\right) = - [(\\Xv + \\Av)^{-1} (\\Xv + \\Av)^{-1}]\\_{ij} \\\\\\\\ & \\Longrightarrow \\frac{\\partial \\tr(\\Xv + \\Av)^{-1}}{\\partial \\Xv} = - (\\Xv + \\Av)^{-1} (\\Xv + \\Av)^{-1} \\end{align*} 取\\Uv = \\Av \\Xv \\Bv，\\Vv = \\Xv^\\top \\Cv，其中\\Av、\\Bv、\\Cv与\\Xv无关，则 \\begin{align*} \\left[ \\frac{\\partial \\tr(\\Av \\Xv \\Bv \\Xv^\\top \\Cv)}{\\partial \\Xv} \\right]_{ij} & = \\tr \\left( \\frac{\\partial (\\Av \\Xv \\Bv)}{\\partial x_{ji}} \\Xv^\\top \\Cv \\right) + \\tr \\left( \\Av \\Xv \\Bv \\frac{\\partial (\\Xv^\\top \\Cv)}{\\partial x_{ji}} \\right) \\\\ & = \\tr \\left( \\Av \\Ev\\_{ji} \\Bv \\Xv^\\top \\Cv \\right) + \\tr \\left( \\Av \\Xv \\Bv \\Ev\\_{ij} \\Cv \\right) \\\\\\\\ & = [\\Bv \\Xv^\\top \\Cv \\Av]\\_{ij} + [\\Cv \\Av \\Xv \\Bv]\\_{ji} \\\\\\\\ & \\Longrightarrow \\frac{\\partial \\tr(\\Av \\Xv \\Bv \\Xv^\\top \\Cv)}{\\partial \\Xv} = \\Bv \\Xv^\\top \\Cv \\Av + \\Bv^\\top \\Xv^\\top \\Av^\\top \\Cv^\\top \\end{align*} 取\\Uv = \\Av \\Xv^\\top \\Bv，\\Vv = \\Xv \\Cv，其中\\Av、\\Bv、\\Cv与\\Xv无关，则 \\begin{align*} \\left[ \\frac{\\partial \\tr(\\Av \\Xv^\\top \\Bv \\Xv \\Cv)}{\\partial \\Xv} \\right]_{ij} & = \\tr \\left( \\frac{\\partial (\\Av \\Xv^\\top \\Bv)}{\\partial x_{ji}} \\Xv \\Cv \\right) + \\tr \\left( \\Av \\Xv^\\top \\Bv \\frac{\\partial (\\Xv \\Cv)}{\\partial x_{ji}} \\right) \\\\ & = \\tr \\left( \\Av \\Ev\\_{ij} \\Bv \\Xv \\Cv \\right) + \\tr \\left( \\Av \\Xv^\\top \\Bv \\Ev\\_{ji} \\Cv \\right) \\\\\\\\ & = [\\Bv \\Xv \\Cv \\Av]\\_{ji} + [\\Cv \\Av \\Xv^\\top \\Bv]\\_{ij} \\\\\\\\ & \\Longrightarrow \\frac{\\partial \\tr(\\Av \\Xv^\\top \\Bv \\Xv \\Cv)}{\\partial \\Xv} = \\Cv \\Av \\Xv^\\top \\Bv + \\Av^\\top \\Cv^\\top \\Xv^\\top \\Bv^\\top \\end{align*} 取\\Uv = \\Bv \\Av与\\Xv无关，\\Vv = \\Xv^n，其中n是正整数，结合式(\\ref{eq: power})可得 \\begin{align*} \\left[ \\frac{\\partial \\tr(\\Bv \\Av \\Xv^n)}{\\partial \\Xv} \\right]_{ij} & = \\tr \\left( \\Bv \\Av \\frac{\\partial \\Xv^n}{\\partial x_{ji}} \\right) = \\tr \\left( \\Bv \\Av \\sum_{k \\in [n]} \\Xv^{k-1} \\frac{\\partial \\Xv}{\\partial x_{ji}} \\Xv^{n-k} \\right) = \\sum_{k \\in [n]} \\tr \\left( \\Bv \\Av \\Xv^{k-1} \\frac{\\partial \\Xv}{\\partial x_{ji}} \\Xv^{n-k} \\right) \\\\ & = \\sum\\_{k \\in [n]} \\tr ( \\Xv^{n-k} \\Bv \\Av \\Xv^{k-1} \\Ev\\_{ji} ) = \\sum\\_{k \\in [n]} [\\Xv^{n-k} \\Bv \\Av \\Xv^{k-1}]\\_{ij} \\\\\\\\ & \\Longrightarrow \\frac{\\partial \\tr(\\Bv \\Av \\Xv^n)}{\\partial \\Xv} = \\frac{\\partial \\tr(\\Av \\Xv^n \\Bv)}{\\partial \\Xv} = \\sum\\_{k \\in [n]} \\Xv^{n-k} \\Bv \\Av \\Xv^{k-1} \\end{align*} 进一步若\\Av = \\Bv = \\Iv，则 \\begin{align*} \\frac{\\partial \\tr(\\Xv^n)}{\\partial \\Xv} = \\sum_{k \\in [n]} \\Xv^{n-k} \\Xv^{k-1} = \\sum_{k \\in [n]} \\Xv^{n-1} = n \\Xv^{n-1} \\end{align*} 不难发现形式上和单变量的求导公式\\partial x^n / \\partial x = n x^{n-1}是一样的。类似的记 \\begin{align*} e^{\\Xv} & = \\Iv + \\Xv + \\frac{\\Xv^2}{2!} + \\frac{\\Xv^3}{3!} + \\cdots \\\\ \\sin \\Xv & = \\Xv - \\frac{\\Xv^3}{3!} + \\frac{\\Xv^5}{5!} - \\cdots \\\\ \\cos \\Xv & = \\Iv - \\frac{\\Xv^2}{2!} + \\frac{\\Xv^4}{4!} - \\frac{\\Xv^6}{6!} + \\cdots \\end{align*} 结合式(\\ref{eq: power})可得 \\begin{align*} \\frac{\\partial \\tr(e^{\\Xv})}{\\partial \\Xv} & = \\frac{\\partial }{\\partial \\Xv} \\tr \\left( \\Iv + \\Xv + \\frac{\\Xv^2}{2!} + \\frac{\\Xv^3}{3!} + \\cdots \\right) \\\\ & = \\frac{\\partial \\tr (\\Iv)}{\\partial \\Xv} + \\frac{\\partial \\tr (\\Xv)}{\\partial \\Xv} + \\frac{1}{2!} \\frac{\\partial \\tr (\\Xv^2)}{\\partial \\Xv} + \\frac{1}{3!} \\frac{\\partial \\tr (\\Xv^3)}{\\partial \\Xv} + \\cdots \\\\\\\\ & = \\Iv + \\Xv + \\frac{\\Xv^2}{2!} + \\cdots = e^{\\Xv} \\end{align*} 以及 \\begin{align*} \\frac{\\partial \\tr(\\sin \\Xv)}{\\partial \\Xv} & = \\frac{\\partial }{\\partial \\Xv} \\tr \\left( \\Xv - \\frac{\\Xv^3}{3!} + \\frac{\\Xv^5}{5!} - \\cdots \\right) \\\\ & = \\frac{1}{1!} \\frac{\\partial \\tr (\\Xv)}{\\partial \\Xv} - \\frac{1}{3!} \\frac{\\partial \\tr (\\Xv^3)}{\\partial \\Xv} + \\frac{1}{5!} \\frac{\\partial \\tr (\\Xv^5)}{\\partial \\Xv} - \\cdots \\\\\\\\ & = \\Iv - \\frac{\\Xv^2}{2!} + \\frac{\\Xv^4}{4!} - \\cdots = \\cos \\Xv \\\\\\\\ \\frac{\\partial \\tr(\\cos \\Xv)}{\\partial \\Xv} & = \\frac{\\partial }{\\partial \\Xv} \\tr \\left( \\Iv - \\frac{\\Xv^2}{2!} + \\frac{\\Xv^4}{4!} - \\frac{\\Xv^6}{6!} + \\cdots \\right) \\\\ & = \\frac{\\partial \\tr (\\Iv)}{\\partial \\Xv} - \\frac{1}{2!} \\frac{\\partial \\tr (\\Xv^2)}{\\partial \\Xv} + \\frac{1}{4!} \\frac{\\partial \\tr (\\Xv^4)}{\\partial \\Xv} - \\frac{1}{6!} \\frac{\\partial \\tr (\\Xv^6)}{\\partial \\Xv} + \\cdots \\\\\\\\ & = - \\Xv + \\frac{\\Xv^3}{3!} - \\frac{\\Xv^5}{5!} + \\cdots = - \\sin \\Xv \\end{align*} 均与单变量的求导公式一样。 取\\Uv = \\Iv，\\Vv = \\Av \\otimes \\Xv，则 \\begin{align*} \\left[ \\frac{\\partial \\tr(\\Av \\otimes \\Xv)}{\\partial \\Xv} \\right]_{ij} & = \\tr \\left( \\frac{\\partial \\Av \\otimes \\Xv}{\\partial x_{ji}} \\right) = \\tr \\left( \\Av \\otimes \\frac{\\partial \\Xv}{\\partial x_{ji}} \\right) = \\tr ( \\Av \\otimes \\Ev_{ji} ) = \\tr(\\Av) \\delta_{ij} \\\\ & \\Longrightarrow \\frac{\\partial \\tr(\\Av \\otimes \\Xv)}{\\partial \\Xv} = \\tr(\\Av) \\Iv \\end{align*} 取\\Uv = \\Iv，\\Vv = \\Xv \\otimes \\Xv，则 \\begin{align*} \\left[ \\frac{\\partial \\tr(\\Xv \\otimes \\Xv)}{\\partial \\Xv} \\right]_{ij} & = \\tr \\left( \\frac{\\partial \\Xv \\otimes \\Xv}{\\partial x_{ji}} \\right) = \\tr \\left( \\frac{\\partial \\Xv}{\\partial x_{ji}} \\otimes \\Xv + \\Xv \\otimes \\frac{\\partial \\Xv}{\\partial x_{ji}} \\right) \\\\ & = \\tr ( \\Ev\\_{ji} \\otimes \\Xv ) + \\tr ( \\Xv \\otimes \\Ev\\_{ji} ) = 2 \\tr(\\Xv) \\delta\\_{ij} \\\\\\\\ & \\Longrightarrow \\frac{\\partial \\tr(\\Xv \\otimes \\Xv)}{\\partial \\Xv} = 2 \\tr(\\Xv) \\Iv \\end{align*} 行列式对矩阵求导 　　设\\Xv \\in \\Rbb^{m \\times n}、\\Av \\in \\Rbb^{l \\times m}、\\Bv \\in \\Rbb^{n \\times l}、\\Yv = \\Av \\Xv \\Bv \\in \\Rbb^{l \\times l}，\\Av、\\Bv与\\Xv无关，结合式(\\ref{eq: chain-matrix})易知 \\begin{align*} \\left[ \\frac{\\partial |\\Av \\Xv \\Bv|}{\\partial \\Xv} \\right]_{ij} = \\frac{\\partial |\\Yv|}{\\partial x_{ji}} = \\sum_p \\sum_q \\frac{\\partial |\\Yv|}{\\partial y_{pq}}\\frac{\\partial y_{pq}}{\\partial x_{ji}} = \\tr \\left( \\frac{\\partial |\\Yv|}{\\partial \\Yv} \\frac{\\partial \\Yv}{\\partial x_{ji}} \\right) \\end{align*} 其中第二项 \\begin{align*} \\frac{\\partial \\Yv}{\\partial x_{ji}} = \\frac{\\partial (\\Av \\Xv \\Bv)}{\\partial x_{ji}} = \\Av \\frac{\\partial \\Xv}{\\partial x_{ji}} \\Bv = \\Av \\Ev_{ji} \\Bv \\end{align*} 记y_{ji}有一个微小增量\\epsilon后的矩阵为\\Yv(y_{ji} + \\epsilon)，根据第j行Laplace展开易知 \\begin{align*} |\\Yv(y_{ji} + \\epsilon)| - |\\Yv| = \\epsilon C_{ji} \\end{align*} 其中C_{ji}是关于y_{ji}的代数余子式，因此 \\begin{align*} \\left[ \\frac{\\partial |\\Yv|}{\\partial \\Yv} \\right]_{ij} = \\frac{\\partial |\\Yv|}{\\partial y_{ji}} = \\lim_{\\epsilon \\rightarrow 0} \\frac{|\\Yv(y_{ji} + \\epsilon)| - |\\Yv|}{\\epsilon} = C_{ji} \\end{align*} 故第一项 \\begin{align*} \\frac{\\partial |\\Yv|}{\\partial \\Yv} = \\begin{bmatrix} C_{11} & C_{21} & \\cdots & C_{n1} \\\\ C_{12} & C_{22} & \\cdots & C_{n2} \\\\ \\vdots & \\vdots & \\ddots & \\vdots \\\\ C_{1n} & C_{2n} & \\cdots & C_{nn} \\end{bmatrix} = \\Yv^ \\end{align\\} 代入可得 \\begin{align*} \\left[ \\frac{\\partial |\\Av \\Xv \\Bv|}{\\partial \\Xv} \\right]_{ij} & = \\tr \\left( \\frac{\\partial |\\Yv|}{\\partial \\Yv} \\frac{\\partial \\Yv}{\\partial x_{ji}} \\right) = \\tr (\\Yv^ \\Av \\Ev_{ji} \\Bv) = [\\Bv \\Yv^ \\Av]_{ij} \\\\ & \\Longrightarrow \\class{blue}{\\frac{\\partial |\\Av \\Xv \\Bv|}{\\partial \\Xv} = \\Bv (\\Av \\Xv \\Bv)^ \\Av} \\end{align\\} 若\\Xv、\\Av、\\Bv均为可逆方阵，则\\Yv = \\Av \\Xv \\Bv亦为可逆方阵，于是 \\begin{align} \\label{eq: determinant} \\frac{\\partial |\\Av \\Xv \\Bv|}{\\partial \\Xv} = \\Bv (\\Av \\Xv \\Bv)^ \\Av = \\Bv |\\Av \\Xv \\Bv| (\\Av \\Xv \\Bv)^{-1} \\Av = |\\Av \\Xv \\Bv| \\Xv^{-1} \\end{align} 进一步若\\Av = \\Bv = \\Iv，则 \\begin{align\\} \\frac{\\partial |\\Xv|}{\\partial \\Xv} = \\Xv^ = |\\Xv| \\Xv^{-1} \\end{align\\} 由此可得 \\begin{align*} \\frac{\\partial |\\Xv^n|}{\\partial \\Xv} = \\frac{\\partial |\\Xv|^n}{\\partial \\Xv} = n |\\Xv|^{n-1} \\Xv^ = n |\\Xv|^n \\Xv^{-1} = n |\\Xv^n| \\Xv^{-1} \\end{align\\} 若a与\\Xv无关，则 \\begin{align*} \\frac{\\partial \\ln |a \\Xv|}{\\partial \\Xv} = \\frac{\\partial \\ln a^m |\\Xv|}{\\partial \\Xv} = \\frac{\\partial \\ln a^m}{\\partial \\Xv} + \\frac{\\partial \\ln |\\Xv|}{\\partial \\Xv} = \\frac{1}{|\\Xv|} \\frac{\\partial |\\Xv|}{\\partial \\Xv} = \\frac{\\Xv^}{|\\Xv|} = \\Xv^{-1} \\end{align\\} 　　设\\Xv \\in \\Rbb^{m \\times n}、\\Av \\in \\Rbb^{m \\times m}、\\Yv = \\Xv^\\top \\Av \\Xv \\in \\Rbb^{n \\times n}可逆，\\Av与\\Xv无关，易知有 \\begin{align*} \\left[ \\frac{\\partial |\\Xv^\\top \\Av \\Xv|}{\\partial \\Xv} \\right]_{ij} & = \\tr \\left( \\Yv^ \\frac{\\partial \\Xv^\\top \\Av \\Xv}{\\partial x_{ji}} \\right) = \\tr \\left( \\Yv^ \\frac{\\partial \\Xv^\\top}{\\partial x_{ji}} \\Av \\Xv \\right) + \\tr \\left( \\Yv^ \\Xv^\\top \\Av \\frac{\\partial \\Xv}{\\partial x_{ji}} \\right) \\\\ & = \\tr ( \\Yv^ \\Ev_{ij} \\Av \\Xv ) + \\tr ( \\Yv^ \\Xv^\\top \\Av \\Ev_{ji} ) = [\\Av \\Xv \\Yv^]_{ji} + [\\Yv^ \\Xv^\\top \\Av]_{ij} \\end{align\\} 于是 \\begin{align*} \\frac{\\partial |\\Xv^\\top \\Av \\Xv|}{\\partial \\Xv} & = (\\Av \\Xv \\Yv^)^\\top + \\Yv^ \\Xv^\\top \\Av = (\\Av \\Xv |\\Xv^\\top \\Av \\Xv| (\\Xv^\\top \\Av \\Xv)^{-1})^\\top + |\\Xv^\\top \\Av \\Xv| (\\Xv^\\top \\Av \\Xv)^{-1} \\Xv^\\top \\Av \\\\ & = |\\Xv^\\top \\Av \\Xv| (\\Xv^\\top \\Av^\\top \\Xv)^{-1} \\Xv^\\top \\Av^\\top + |\\Xv^\\top \\Av \\Xv| (\\Xv^\\top \\Av \\Xv)^{-1} \\Xv^\\top \\Av \\\\ & = |\\Xv^\\top \\Av \\Xv| ((\\Xv^\\top \\Av^\\top \\Xv)^{-1} \\Xv^\\top \\Av^\\top + (\\Xv^\\top \\Av \\Xv)^{-1} \\Xv^\\top \\Av) \\end{align*} 若\\Av对称，则 \\begin{align*} \\frac{\\partial |\\Xv^\\top \\Av \\Xv|}{\\partial \\Xv} = 2 |\\Xv^\\top \\Av \\Xv| (\\Xv^\\top \\Av \\Xv)^{-1} \\Xv^\\top \\Av \\end{align*} 若\\Xv、\\Av是方阵，则其均可逆，于是 \\begin{align*} \\frac{\\partial |\\Xv^\\top \\Av \\Xv|}{\\partial \\Xv} = 2 |\\Xv^\\top| |\\Av| |\\Xv| \\Xv^{-1} \\Av^{-1} \\Xv^{-\\top} \\Xv^\\top \\Av = 2 |\\Xv|^2 |\\Av| \\Xv^{-1} \\end{align*} 若\\Av = \\Iv，则 \\begin{align*} \\frac{\\partial |\\Xv^\\top \\Xv|}{\\partial \\Xv} = 2 |\\Xv^\\top \\Xv| (\\Xv^\\top \\Xv)^{-1} \\Xv^\\top = 2 |\\Xv^\\top \\Xv| \\Xv^\\dagger \\end{align*} 以及 \\begin{align*} \\frac{\\partial \\ln |\\Xv^\\top \\Xv|}{\\partial \\Xv} = \\frac{1}{|\\Xv^\\top \\Xv|} \\frac{\\partial |\\Xv^\\top \\Xv|}{\\partial \\Xv} = 2 \\Xv^\\dagger \\end{align*} Copyright © Avanti 2020 all right reserved，powered by Gitbook文件最后修改时间： 2021-11-14 16:13:10 "},"posts/matrix/Strassen.html":{"url":"posts/matrix/Strassen.html","title":"乘法加速","keywords":"","body":"　　设矩阵\\Av = (a_{ij})和\\Bv = (b_{ij})是n阶方阵，乘积\\Cv = (c_{ij})亦是n阶方阵，其中 \\begin{align*} c_{ij} = \\sum_{k \\in [n]} a_{ik} b_{kj} \\end{align*} 因此按标准的矩阵乘法，计算\\Cv的时间开销为\\Omega(n^3)，事实上这个时间复杂度是可以改进的。 分治递归 　　设计算\\Cv的时间开销为T(n)，将矩阵分成2 \\times 2 = 4块，由分块矩阵乘法有 \\begin{align*} \\begin{bmatrix} \\Cv_{11} & \\Cv_{12} \\\\ \\Cv_{21} & \\Cv_{22} \\end{bmatrix} = \\begin{bmatrix} \\Av_{11} & \\Av_{12} \\\\ \\Av_{21} & \\Av_{22} \\end{bmatrix} \\begin{bmatrix} \\Bv_{11} & \\Bv_{12} \\\\ \\Bv_{21} & \\Bv_{22} \\end{bmatrix} = \\begin{bmatrix} \\Av_{11} \\Bv_{11} + \\Av_{12} \\Bv_{21} & \\Av_{11} \\Bv_{12} + \\Av_{12} \\Bv_{22} \\\\ \\Av_{21} \\Bv_{11} + \\Av_{22} \\Bv_{21} & \\Av_{21} \\Bv_{12} + \\Av_{22} \\Bv_{22} \\end{bmatrix} \\end{align*} 其中包含8个n/2阶方阵相乘、4个n/2阶方阵相加，注意每个n/2阶方阵有n^2/4个元素，因此共需进行n^2次加法，综上有递推关系 \\begin{align*} T(n) = 8 \\cdot T(n/2) + c_1 n^2 \\end{align*} 其中c_1为单次加法的时间开销。设n = 2^k，则 \\begin{align*} T(2^k) & = 8^1 \\cdot T(2^{k-1}) + 8^0 \\cdot c_1 4^k \\\\ 8^1 \\cdot T(2^{k-1}) & = 8^2 \\cdot T(2^{k-2}) + 8^1 \\cdot c_1 4^{k-1} \\\\ 8^2 \\cdot T(2^{k-2}) & = 8^3 \\cdot T(2^{k-3}) + 8^2 \\cdot c_1 4^{k-2} \\\\ & \\vdots \\\\ 8^{k-1} \\cdot T(2^1) & = 8^k \\cdot T(2^0) + 8^{k-1} \\cdot c_1 4^1 \\end{align*} 注意8^k = n^3，T(1) = c_2是单次乘法的时间开销，累加可得 \\begin{align*} T(n) & = c_2 n^3 + c_1 4^k + 2^1 \\cdot c_1 4^k + 2^2 \\cdot c_1 4^k + \\cdots + 2^{k-1} \\cdot c_1 4^k \\\\ & = c_2 n^3 + c_1 4^k \\frac{1-2^k}{1-2} \\\\ & = c_2 n^3 + c_1 n^2 (n-1) \\\\ & = (c_2 + c_1) n^3 - c_1 n^2 \\end{align*} 即直接分治递归并不能改进时间复杂度。 基本想法 　　要想改进时间复杂度，必须得减少子问题的个数，即乘法的次数。将乘积拉直，易知 \\begin{align*} \\begin{bmatrix} \\Av_{11} \\Bv_{11} + \\Av_{12} \\Bv_{21} \\\\ \\Av_{11} \\Bv_{12} + \\Av_{12} \\Bv_{22} \\\\ \\Av_{21} \\Bv_{11} + \\Av_{22} \\Bv_{21} \\\\ \\Av_{21} \\Bv_{12} + \\Av_{22} \\Bv_{22} \\end{bmatrix} = \\begin{bmatrix} \\Av_{11} & \\zerov & \\Av_{12} & \\zerov \\\\ \\zerov & \\Av_{11} & \\zerov & \\Av_{12} \\\\ \\Av_{21} & \\zerov & \\Av_{22} & \\zerov \\\\ \\zerov & \\Av_{21} & \\zerov & \\Av_{22} \\end{bmatrix} \\begin{bmatrix} \\Bv_{11} \\\\ \\Bv_{12} \\\\ \\Bv_{21} \\\\ \\Bv_{22} \\end{bmatrix} \\end{align*} 假设 \\begin{align} \\label{eq: decomposition} \\class{blue}{\\begin{bmatrix} \\Av_{11} & \\zerov & \\Av_{12} & \\zerov \\\\ \\zerov & \\Av_{11} & \\zerov & \\Av_{12} \\\\ \\Av_{21} & \\zerov & \\Av_{22} & \\zerov \\\\ \\zerov & \\Av_{21} & \\zerov & \\Av_{22} \\end{bmatrix} = \\sum_{i \\in [m]} \\begin{bmatrix} \\Pv_{i1} \\\\ \\Pv_{i2} \\\\ \\Pv_{i3} \\\\ \\Pv_{i4} \\end{bmatrix} \\Rv_i \\begin{bmatrix} \\Qv_{i1} \\\\ \\Qv_{i2} \\\\ \\Qv_{i3} \\\\ \\Qv_{i4} \\end{bmatrix}^\\top} \\end{align} 且\\Rv_i只由\\Av_{11}, \\Av_{12}, \\Av_{21}, \\Av_{22}进行加减运算得到，\\Pv_{i1}, \\ldots,\\Pv_{i4}, \\Qv_{i1}, \\ldots, \\Qv_{i4} \\in \\{ \\pm \\Iv, \\zerov \\}，于是 \\begin{align*} \\begin{bmatrix} \\Av_{11} \\Bv_{11} + \\Av_{12} \\Bv_{21} \\\\ \\Av_{11} \\Bv_{12} + \\Av_{12} \\Bv_{22} \\\\ \\Av_{21} \\Bv_{11} + \\Av_{22} \\Bv_{21} \\\\ \\Av_{21} \\Bv_{12} + \\Av_{22} \\Bv_{22} \\end{bmatrix} = \\sum_{i \\in [m]} \\begin{bmatrix} \\Pv_{i1} \\\\ \\Pv_{i2} \\\\ \\Pv_{i3} \\\\ \\Pv_{i4} \\end{bmatrix} \\Rv_i \\class{green}{\\begin{bmatrix} \\Qv_{i1} \\\\ \\Qv_{i2} \\\\ \\Qv_{i3} \\\\ \\Qv_{i4} \\end{bmatrix}^\\top \\begin{bmatrix} \\Bv_{11} \\\\ \\Bv_{12} \\\\ \\Bv_{21} \\\\ \\Bv_{22} \\end{bmatrix}} = \\sum_{i \\in [m]} \\begin{bmatrix} \\Pv_{i1} \\\\ \\Pv_{i2} \\\\ \\Pv_{i3} \\\\ \\Pv_{i4} \\end{bmatrix} \\Rv_i \\class{green}{\\Sv_i} = \\sum_{i \\in [m]} \\begin{bmatrix} \\Pv_{i1} \\\\ \\Pv_{i2} \\\\ \\Pv_{i3} \\\\ \\Pv_{i4} \\end{bmatrix} \\Tv_i \\end{align*} 其中\\Sv_i = \\Qv_{i1} \\Bv_{11} + \\Qv_{i2} \\Bv_{12} + \\Qv_{i3} \\Bv_{21} + \\Qv_{i4} \\Bv_{22}只由\\Bv_{11}, \\Bv_{12}, \\Bv_{21}, \\Bv_{22}进行加减运算得到。计算全部m个\\Tv_i = \\Rv_i \\Sv_i会产生m个子问题。又\\Pv_{i1}, \\ldots, \\Pv_{i4} \\in \\{ \\pm \\Iv, \\zerov \\}，因此 \\begin{align*} \\begin{bmatrix} \\Av_{11} \\Bv_{11} + \\Av_{12} \\Bv_{21} \\\\ \\Av_{11} \\Bv_{12} + \\Av_{12} \\Bv_{22} \\\\ \\Av_{21} \\Bv_{11} + \\Av_{22} \\Bv_{21} \\\\ \\Av_{21} \\Bv_{12} + \\Av_{22} \\Bv_{22} \\end{bmatrix} = \\sum_{i \\in [m]} \\begin{bmatrix} \\Pv_{i1} \\\\ \\Pv_{i2} \\\\ \\Pv_{i3} \\\\ \\Pv_{i4} \\end{bmatrix} \\Tv_i = \\begin{bmatrix} \\Pv_{11} \\Tv_1 + \\cdots + \\Pv_{m1} \\Tv_m \\\\ \\Pv_{12} \\Tv_1 + \\cdots + \\Pv_{m2} \\Tv_m \\\\ \\Pv_{13} \\Tv_1 + \\cdots + \\Pv_{m3} \\Tv_m \\\\ \\Pv_{14} \\Tv_1 + \\cdots + \\Pv_{m4} \\Tv_m \\end{bmatrix} \\end{align*} 只由\\Tv_1, \\ldots, \\Tv_m进行加减运算得到。综上，关键就是如何使式(\\ref{eq: decomposition})中的m 。 　　下面给出一个m = 7的分解方法，首先去掉左上的\\Av_{11}和右下的\\Av_{22} \\begin{align*} \\text{remainder} & = \\begin{bmatrix} \\Av_{11} & \\zerov & \\Av_{12} & \\zerov \\\\ \\zerov & \\Av_{11} & \\zerov & \\Av_{12} \\\\ \\Av_{21} & \\zerov & \\Av_{22} & \\zerov \\\\ \\zerov & \\Av_{21} & \\zerov & \\Av_{22} \\end{bmatrix} - \\begin{bmatrix} \\Av_{11} & \\zerov & \\Av_{11} & \\zerov \\\\ \\zerov & \\zerov & \\zerov & \\zerov \\\\ \\Av_{11} & \\zerov & \\Av_{11} & \\zerov \\\\ \\zerov & \\zerov & \\zerov & \\zerov \\end{bmatrix} - \\begin{bmatrix} \\zerov & \\zerov & \\zerov & \\zerov \\\\ \\zerov & \\Av_{22} & \\zerov & \\Av_{22} \\\\ \\zerov & \\zerov & \\zerov & \\zerov \\\\ \\zerov & \\Av_{22} & \\zerov & \\Av_{22} \\end{bmatrix} \\\\ & = \\begin{bmatrix} \\zerov & \\zerov & \\Av_{12} - \\Av_{11} & \\zerov \\\\ \\zerov & \\Av_{11} - \\Av_{22} & \\zerov & \\Av_{12} - \\Av_{22} \\\\ \\Av_{21} - \\Av_{11} & \\zerov & \\Av_{22} - \\Av_{11} & \\zerov \\\\ \\zerov & \\Av_{21} - \\Av_{22} & \\zerov & \\zerov \\end{bmatrix} \\\\ & = \\begin{bmatrix} \\zerov & \\zerov & \\zerov & \\zerov \\\\ \\zerov & \\Av_{11} - \\Av_{22} & \\Av_{11} - \\Av_{22} & \\zerov \\\\ \\zerov & \\Av_{22} - \\Av_{11} & \\Av_{22} - \\Av_{11} & \\zerov \\\\ \\zerov & \\zerov & \\zerov & \\zerov \\end{bmatrix} + \\begin{bmatrix} \\zerov & \\zerov & \\Av_{12} - \\Av_{11} & \\zerov \\\\ \\zerov & \\zerov & \\Av_{22} - \\Av_{11} & \\Av_{12} - \\Av_{22} \\\\ \\Av_{21} - \\Av_{11} & \\Av_{11} - \\Av_{22} & \\zerov & \\zerov \\\\ \\zerov & \\Av_{21} - \\Av_{22} & \\zerov & \\zerov \\end{bmatrix} \\end{align*} 注意 \\begin{align*} \\begin{bmatrix} \\zerov & \\zerov & \\Av_{12} - \\Av_{11} & \\zerov \\\\ \\zerov & \\zerov & \\Av_{22} - \\Av_{11} & \\Av_{12} - \\Av_{22} \\\\ \\zerov & \\zerov & \\zerov & \\zerov \\\\ \\zerov & \\zerov & \\zerov & \\zerov \\end{bmatrix} & = \\begin{bmatrix} \\zerov & \\zerov & \\zerov & \\zerov \\\\ \\zerov & \\zerov & \\Av_{22} - \\Av_{12} & \\Av_{12} - \\Av_{22} \\\\ \\zerov & \\zerov & \\zerov & \\zerov \\\\ \\zerov & \\zerov & \\zerov & \\zerov \\end{bmatrix} + \\begin{bmatrix} \\zerov & \\zerov & \\Av_{12} - \\Av_{11} & \\zerov \\\\ \\zerov & \\zerov & \\Av_{12} - \\Av_{11} & \\zerov \\\\ \\zerov & \\zerov & \\zerov & \\zerov \\\\ \\zerov & \\zerov & \\zerov & \\zerov \\end{bmatrix} \\\\ \\begin{bmatrix} \\zerov & \\zerov & \\zerov & \\zerov \\\\ \\zerov & \\zerov & \\zerov & \\zerov \\\\ \\Av_{21} - \\Av_{11} & \\Av_{11} - \\Av_{22} & \\zerov & \\zerov \\\\ \\zerov & \\Av_{21} - \\Av_{22} & \\zerov & \\zerov \\end{bmatrix} & = \\begin{bmatrix} \\zerov & \\zerov & \\zerov & \\zerov \\\\ \\zerov & \\zerov & \\zerov & \\zerov \\\\ \\Av_{21} - \\Av_{11} & \\Av_{11} - \\Av_{21} & \\zerov & \\zerov \\\\ \\zerov & \\zerov & \\zerov & \\zerov \\\\ \\end{bmatrix} + \\begin{bmatrix} \\zerov & \\zerov & \\zerov & \\zerov \\\\ \\zerov & \\zerov & \\zerov & \\zerov \\\\ \\zerov & \\Av_{21} - \\Av_{22} & \\zerov & \\zerov \\\\ \\zerov & \\Av_{21} - \\Av_{22} & \\zerov & \\zerov \\end{bmatrix} \\end{align*} 综上 \\begin{align*} & \\begin{bmatrix} \\Av_{11} & \\zerov & \\Av_{12} & \\zerov \\\\ \\zerov & \\Av_{11} & \\zerov & \\Av_{12} \\\\ \\Av_{21} & \\zerov & \\Av_{22} & \\zerov \\\\ \\zerov & \\Av_{21} & \\zerov & \\Av_{22} \\end{bmatrix} = \\begin{bmatrix} \\Av_{11} & \\zerov & \\Av_{11} & \\zerov \\\\ \\zerov & \\zerov & \\zerov & \\zerov \\\\ \\Av_{11} & \\zerov & \\Av_{11} & \\zerov \\\\ \\zerov & \\zerov & \\zerov & \\zerov \\end{bmatrix} + \\begin{bmatrix} \\zerov & \\zerov & \\zerov & \\zerov \\\\ \\zerov & \\Av_{22} & \\zerov & \\Av_{22} \\\\ \\zerov & \\zerov & \\zerov & \\zerov \\\\ \\zerov & \\Av_{22} & \\zerov & \\Av_{22} \\end{bmatrix} + \\begin{bmatrix} \\zerov & \\zerov & \\zerov & \\zerov \\\\ \\zerov & \\Av_{11} - \\Av_{22} & \\Av_{11} - \\Av_{22} & \\zerov \\\\ \\zerov & \\Av_{22} - \\Av_{11} & \\Av_{22} - \\Av_{11} & \\zerov \\\\ \\zerov & \\zerov & \\zerov & \\zerov \\end{bmatrix} \\\\ & \\qquad \\qquad + \\begin{bmatrix} \\zerov & \\zerov & \\zerov & \\zerov \\\\ \\zerov & \\zerov & \\Av_{22} - \\Av_{12} & \\Av_{12} - \\Av_{22} \\\\ \\zerov & \\zerov & \\zerov & \\zerov \\\\ \\zerov & \\zerov & \\zerov & \\zerov \\end{bmatrix} + \\begin{bmatrix} \\zerov & \\zerov & \\Av_{12} - \\Av_{11} & \\zerov \\\\ \\zerov & \\zerov & \\Av_{12} - \\Av_{11} & \\zerov \\\\ \\zerov & \\zerov & \\zerov & \\zerov \\\\ \\zerov & \\zerov & \\zerov & \\zerov \\end{bmatrix} \\\\ & \\qquad \\qquad + \\begin{bmatrix} \\zerov & \\zerov & \\zerov & \\zerov \\\\ \\zerov & \\zerov & \\zerov & \\zerov \\\\ \\Av_{21} - \\Av_{11} & \\Av_{11} - \\Av_{21} & \\zerov & \\zerov \\\\ \\zerov & \\zerov & \\zerov & \\zerov \\end{bmatrix} + \\begin{bmatrix} \\zerov & \\zerov & \\zerov & \\zerov \\\\ \\zerov & \\zerov & \\zerov & \\zerov \\\\ \\zerov & \\Av_{21} - \\Av_{22} & \\zerov & \\zerov \\\\ \\zerov & \\Av_{21} - \\Av_{22} & \\zerov & \\zerov \\end{bmatrix} \\\\ & \\qquad = \\begin{bmatrix} \\Iv \\\\ \\zerov \\\\ \\Iv \\\\ \\zerov \\end{bmatrix} \\Av_{11} \\begin{bmatrix} \\Iv \\\\ \\zerov \\\\ \\Iv \\\\ \\zerov \\end{bmatrix}^\\top + \\begin{bmatrix} \\zerov \\\\ \\Iv \\\\ \\zerov \\\\ \\Iv \\end{bmatrix} \\Av_{22} \\begin{bmatrix} \\zerov \\\\ \\Iv \\\\ \\zerov \\\\ \\Iv \\end{bmatrix}^\\top + \\begin{bmatrix} \\zerov \\\\ \\Iv \\\\ -\\Iv \\\\ \\zerov \\end{bmatrix} (\\Av_{11} - \\Av_{22}) \\begin{bmatrix} \\zerov \\\\ \\Iv \\\\ \\Iv \\\\ \\zerov \\end{bmatrix}^\\top + \\begin{bmatrix} \\zerov \\\\ \\Iv \\\\ \\zerov \\\\ \\zerov \\end{bmatrix} (\\Av_{22} - \\Av_{12}) \\begin{bmatrix} \\zerov \\\\ \\zerov \\\\ \\Iv \\\\ -\\Iv \\end{bmatrix}^\\top \\\\ & \\qquad \\qquad + \\begin{bmatrix} \\Iv \\\\ \\Iv \\\\ \\zerov \\\\ \\zerov \\end{bmatrix} (\\Av_{12} - \\Av_{11}) \\begin{bmatrix} \\zerov \\\\ \\zerov \\\\ \\Iv \\\\ \\zerov \\end{bmatrix}^\\top + \\begin{bmatrix} \\zerov \\\\ \\zerov \\\\ \\Iv \\\\ \\zerov \\end{bmatrix} (\\Av_{21} - \\Av_{11}) \\begin{bmatrix} \\Iv \\\\ -\\Iv \\\\ \\zerov \\\\ \\zerov \\end{bmatrix}^\\top + \\begin{bmatrix} \\zerov \\\\ \\zerov \\\\ \\Iv \\\\ \\Iv \\end{bmatrix} (\\Av_{21} - \\Av_{22}) \\begin{bmatrix} \\zerov \\\\ \\Iv \\\\ \\zerov \\\\ \\zerov \\end{bmatrix}^\\top \\end{align*} 算法实现 　　根据上面的分解，计算 \\begin{align*} & \\Sv_1 = \\Bv_{11} + \\Bv_{21}, \\quad \\Sv_2 = \\Bv_{12} + \\Bv_{22}, \\quad \\Sv_3 = \\Bv_{12} + \\Bv_{21} \\\\ & \\Sv_4 = \\Bv_{21} - \\Bv_{22}, \\quad \\Sv_5 = \\Bv_{21}, \\quad \\Sv_6 = \\Bv_{11} - \\Bv_{12}, \\quad \\Sv_7 = \\Bv_{12} \\end{align*} 共会产生5次加减运算，计算 \\begin{align*} & \\Rv_1 = \\Av_{11}, \\quad \\Rv_2 = \\Av_{22}, \\quad \\Rv_3 = \\Av_{11} - \\Av_{22}, \\quad \\Rv_4 = \\Av_{22} - \\Av_{12} \\\\ & \\Rv_5 = \\Av_{12} - \\Av_{11}, \\quad \\Rv_6 = \\Av_{21} - \\Av_{11}, \\quad \\Rv_7 = \\Av_{21} - \\Av_{22} \\end{align*} 共会产生5次加减运算，计算 \\begin{align*} \\Tv_1 = \\Rv_1 \\Sv_1, \\quad \\Tv_2 = \\Rv_2 \\Sv_2, \\quad \\Tv_3 = \\Rv_3 \\Sv_3, \\quad \\Tv_4 = \\Rv_4 \\Sv_4, \\quad \\Tv_5 = \\Rv_5 \\Sv_5, \\quad \\Tv_6 = \\Rv_6 \\Sv_6, \\quad \\Tv_7 = \\Rv_7 \\Sv_7 \\end{align*} 共会产生7个子问题，计算 \\begin{align*} \\Av_{11} \\Bv_{11} + \\Av_{12} \\Bv_{21} & = \\Tv_1 + \\Tv_5 \\\\ \\Av_{11} \\Bv_{12} + \\Av_{12} \\Bv_{22} & = \\Tv_2 + \\Tv_3 + \\Tv_4 + \\Tv_5 \\\\ \\Av_{21} \\Bv_{11} + \\Av_{22} \\Bv_{21} & = \\Tv_1 - \\Tv_3 + \\Tv_6 + \\Tv_7 \\\\ \\Av_{21} \\Bv_{12} + \\Av_{22} \\Bv_{22} & = \\Tv_2 + \\Tv_7 \\end{align*} 共会产生8次加减运算。 　　综上，一共会产生7个子问题和18次加减运算，此时递推关系变成 \\begin{align*} T(n) = 7 \\cdot T(n/2) + \\frac{18}{4} c_1 n^2 \\end{align*} 设n = 2^k，则 \\begin{align*} T(2^k) & = 7^1 \\cdot T(2^{k-1}) + \\frac{18}{4} c_1 4^k \\\\ 7^1 \\cdot T(2^{k-1}) & = 7^2 \\cdot T(2^{k-2}) + 7^1 \\frac{18}{4} c_1 4^{k-1} \\\\ 7^2 \\cdot T(2^{k-2}) & = 7^3 \\cdot T(2^{k-3}) + 7^2 \\frac{18}{4} c_1 4^{k-2} \\\\ & \\vdots \\\\ 7^{k-1} \\cdot T(2^1) & = 7^k \\cdot T(2^0) + 7^{k-1} \\frac{18}{4} c_1 4^1 \\end{align*} 注意7^k = (2^{\\lg 7})^k = (2^k)^{\\lg 7} = n^{\\lg 7} \\approx n^{2.81}， 累加可得 \\begin{align*} T(n) = c_2 n^{\\lg 7} + \\frac{18}{4} c_1 4^k \\frac{1-(7/4)^k}{1-(7/4)} = c_2 n^{\\lg 7} + 6 c_1 (n^{\\lg 7} - n^2) = \\left( c_2 + 6 c_1 \\right) n^{\\lg 7} - 6 c_1 n^2 \\end{align*} Copyright © Avanti 2020 all right reserved，powered by Gitbook文件最后修改时间： 2021-11-14 15:55:00 "},"posts/matrix/TU-matrix.html":{"url":"posts/matrix/TU-matrix.html","title":"全幺模矩阵","keywords":"","body":"　　若矩阵\\Av的任意子方阵的行列式\\in \\{ 0, \\pm 1 \\}，则称\\Av为全幺模矩阵(totally unimodular matrix)。 　　全幺模对于取负、转置、交换行列、拼接自身、拼接单位向量等操作是封闭的：若\\Av是全幺模矩阵，则 \\Av的任意子矩阵\\Bv也是全幺模矩阵，因为\\Bv的任意子方阵也是\\Av的子方阵，特别的\\Av的任意元素都\\in \\{ 0, \\pm 1 \\}。 -\\Av是全幺模矩阵，设\\Av'是-\\Av的任意子方阵，则-\\Av'是\\Av的子方阵，于是\\det(-\\Av') \\in \\{ 0, \\pm 1 \\}，从而\\det(\\Av') \\in \\{ 0, \\pm 1 \\}。 \\Av^\\top是全幺模矩阵，设\\Av'是\\Av^\\top的任意子方阵，则\\Av'^\\top是\\Av的子方阵，于是\\det(\\Av'^\\top) \\in \\{ 0, \\pm 1 \\}，从而\\det(\\Av') \\in \\{ 0, \\pm 1 \\}。 把\\Av的两行/两列互换得到的矩阵\\Bv是全幺模矩阵，因为\\Bv的任意子方阵都可以通过\\Av的某个子方阵交换行/列得到，而交换行/列只改变行列式的符号。 [\\Av, \\pm \\Av]是全幺模矩阵，设\\Bv是[\\Av, \\pm \\Av]的任意子方阵，则\\Bv的每一列要么来自于\\Av的某一列，要么来自于\\pm \\Av的某一列。若有两列相同或仅差一个符号，则\\Bv是奇异矩阵，从而\\det(\\Bv) = 0；否则\\Bv可直接由\\Av的某个子方阵得到(最多对部分列再取负)，这只会影响行列式的符号，此时有\\det(\\Bv) \\in \\{ 0, \\pm 1 \\}。 [\\Av, \\pm \\Iv]是全幺模矩阵，设\\Bv是[\\Av, \\pm \\Iv]的任意非奇异子方阵，若\\Bv是\\Av或\\pm \\Iv其中之一的子方阵，易知有|\\det(\\Bv)| = 1，否则设\\Bv = [\\overline{\\Av}, \\pm \\overline{\\Iv}]，其中\\overline{\\Av}、\\overline{\\Iv}分别是\\Av和\\Iv的子矩阵且都是列满秩的(否则\\Bv奇异)，交换\\Bv的某些行可得 \\begin{align*} \\overline{\\Bv} = \\begin{bmatrix} \\overline{\\Av}_1 & \\zerov \\\\ \\overline{\\Av}_2 & \\pm \\hat{\\Iv} \\end{bmatrix} \\end{align*} 于是|\\det(\\overline{\\Bv})| = |\\det(\\overline{\\Av}_1)| \\cdot |\\det(\\pm \\hat{\\Iv})| = |\\det(\\overline{\\Av}_1)|，而\\overline{\\Av}_1是\\Av的某个非奇异子方阵交换行得到的，故|\\det(\\Bv)| = |\\det(\\overline{\\Bv})| = |\\det(\\overline{\\Av}_1)| = 1。 [\\Av; \\pm \\Iv]是全幺模矩阵，因为[\\Av; \\pm \\Iv] = [\\Av^\\top, \\pm \\Iv]^\\top，其中\\Av^\\top是全幺模矩阵，故[\\Av^\\top, \\pm \\Iv]是全幺模矩阵，取转置后依然是全幺模矩阵。 　　全幺模矩阵导出的凸多面体的极点是整数向量，若这样的凸多面体是某个线性规划的可行域，那么该线性规划的最优解是整数解，换言之相应的整数线性规划可以通过放松成一般的线性规划来做。 定理1. 设\\Av \\in \\{ 0, \\pm 1 \\}^{m \\times n}是全幺模矩阵，\\bv \\in \\Zbb^m是整数向量，则凸多面体\\Pcal = \\{ \\xv \\in \\Rbb^n \\mid \\Av \\xv \\leq \\bv \\}的极点都是整数向量。 证明：设\\vv是\\Pcal的极点，则存在n元下标集合\\Ical \\subseteq [m]使得\\Av_{\\Ical,:} \\vv = \\bv_{\\Ical}，由Cramer法则知 \\begin{align*} v_i = \\frac{\\det(\\Av_{\\Ical,:}^{(i)}|\\bv_{\\Ical})}{\\det(\\Av_{\\Ical,:})} \\end{align*} 其中\\Av_{\\Ical,:}^{(i)}|\\bv_{\\Ical}是将\\Av_{\\Ical,:}的第i列替换成\\bv_{\\Ical}得到的矩阵。注意\\Av_{\\Ical,:}是\\Av的n阶非奇异子方阵，因此\\det(\\Av_{\\Ical,:}) = \\pm 1。将\\Av_{\\Ical,:}^{(i)}|\\bv_{\\Ical}按第i列展开，由于\\bv_{\\Ical}是整数向量，而展开中涉及的代数余子式又都\\in \\{ 0, \\pm 1 \\}，因此\\det(\\Av_{\\Ical,:}^{(i)}|\\bv_{\\Ical})也是整数，故v_i是整数。 　　全幺模矩阵跟图也有联系。 定理2. 对于二部图\\Gcal = (\\Vcal = \\Vcal_1 \\uplus \\Vcal_2, \\Ecal)，其关联矩阵\\Av \\in \\{ 0,1 \\}^{|\\Vcal| \\times |\\Ecal|}是全幺模矩阵。 证明：对子矩阵的阶数k做归纳，k=1的情形是显然的，因为\\Av的每个元素都\\in \\{ 0,1 \\} \\subseteq \\{ 0, \\pm 1 \\}。设\\Av'是\\Av的k阶子矩阵，注意\\Av'的每列最多有两个1，其余均为零。 若有一列全零，则\\Av'为奇异矩阵，从而\\det(\\Av') = 0 \\in \\{ 0, \\pm 1 \\}。 若有一列恰有一个1，按该列展开，设\\Av''是将1所在行、列删除后得到的矩阵，则\\det(\\Av') = \\pm \\det (\\Av'')，由归纳假设知\\det (\\Av'') \\in \\{ 0, \\pm 1 \\}，故\\det(\\Av') \\in \\{ 0, \\pm 1 \\}。 若每列都有两个1，由于\\Gcal是二部图，可将\\Av'按行分成两部分，分别对应\\Vcal_1中的点和\\Vcal_2中的点，显然第一部分的行和减去第二部分行和为\\zerov，故\\Av'是奇异矩阵，从而\\det(\\Av') = 0 \\in \\{ 0, \\pm 1 \\}。 定理3. 有向图\\Gcal = (\\Vcal, \\Ecal)的关联矩阵\\Av \\in \\{ 0, \\pm 1 \\}^{|\\Vcal| \\times |\\Ecal|}是全幺模矩阵。 证明：对子矩阵的阶数k做归纳，k=1的情形是显然的，注意\\Av'的每列最多有两个非零元素，其余均为零。 若有一列全零，则\\Av'为奇异矩阵，从而\\det(\\Av') = 0 \\in \\{ 0, \\pm 1 \\}。 若有一列恰有一个1或-1，按该列展开，设\\Av''是将非零元素所在行、列删除后得到的矩阵，则\\det(\\Av') = \\pm \\det (\\Av'')，由归纳假设知\\det (\\Av'') \\in \\{ 0, \\pm 1 \\}，故\\det(\\Av') \\in \\{ 0, \\pm 1 \\}。 若每列都有一个1、一个-1，则\\Av'的所有行相加为\\zerov，故\\Av'是奇异矩阵，从而\\det(\\Av') = 0 \\in \\{ 0, \\pm 1 \\}。 附录 　　考虑线性方程组x_1 \\av_1 + x_2 \\av_2 + \\cdots + x_n \\av_n = \\bv，易知 \\begin{align*} \\det (\\cdots, \\av_{i-1}, \\bv, \\av_{i+1}, \\cdots) & = \\det (\\cdots, \\av_{i-1}, \\sum_{j \\in [n]} x_j \\av_j, \\av_{i+1}, \\cdots) \\\\ & = \\sum_{j \\in [n]} x_j \\det (\\cdots, \\av_{i-1}, \\av_j, \\av_{i+1}, \\cdots) \\\\ & = x_i \\det (\\cdots, \\av_{i-1}, \\av_i, \\av_{i+1}, \\cdots) \\end{align*} 故 \\begin{align*} x_i = \\frac{\\det (\\cdots, \\av_{i-1}, \\bv, \\av_{i+1}, \\cdots)}{\\det (\\cdots, \\av_{i-1}, \\av_i, \\av_{i+1}, \\cdots)} \\end{align*} 该求解公式称为Cramer法则。 　　 Copyright © Avanti 2020 all right reserved，powered by Gitbook文件最后修改时间： 2021-06-19 10:20:29 "},"posts/matrix/nuclear-norm-ball.html":{"url":"posts/matrix/nuclear-norm-ball.html","title":"核范数球","keywords":"","body":"　　向量的\\ell_p范数球都很容易可视化，但是矩阵的就没那么容易了，不过\\Sbb_2的核范数球是可以的。设 \\begin{align*} \\Mv = \\begin{bmatrix} x & y \\\\ y & z \\end{bmatrix}, \\quad \\Mv^\\top \\Mv = \\begin{bmatrix} x & y \\\\ y & z \\end{bmatrix} \\begin{bmatrix} x & y \\\\ y & z \\end{bmatrix} = \\begin{bmatrix} x^2 + y^2 & y (x + z) \\\\ y (x + z) & y^2 + z^2 \\end{bmatrix} \\end{align*} 于是\\Mv^\\top \\Mv的特征方程为 \\begin{align*} 0 & = t^2 - (x^2 + 2 y^2 + z^2) t + (x^2 + y^2) (y^2 + z^2) - y^2 (x + z)^2 \\\\ & = t^2 - (x^2 + 2 y^2 + z^2) t + x^2 z^2 + y^4 + y^2 (x^2 + z^2) - y^2 (x + z)^2 \\\\ & = t^2 - (x^2 + 2 y^2 + z^2) t + x^2 z^2 + y^4 - y^2 \\cdot 2 x z \\\\ & = t^2 - (x^2 + 2 y^2 + z^2) t + (y^2 - xz)^2 \\end{align*} 易知两个特征根分别为 \\begin{align*} t_{1,2} = \\frac{x^2 + 2 y^2 + z^2 \\pm \\sqrt{(x^2 + 2 y^2 + z^2)^2 - 4 (y^2 - xz)^2}}{2} \\end{align*} 故\\Mv的两个奇异值分别为 \\begin{align*} \\sigma_{1,2} = \\frac{1}{\\sqrt{2}} \\sqrt{x^2 + 2 y^2 + z^2 \\pm \\sqrt{(x^2 + 2 y^2 + z^2)^2 - 4 (y^2 - xz)^2}} \\end{align*} 　　显然\\|\\Mv\\|_* \\le 1的边界为\\|\\Mv\\|_* = 1，即\\sigma_1 + \\sigma_2 = 1，两边平方可得 \\begin{align*} 1 & = \\sigma_1^2 + \\sigma_2^2 + 2 \\sigma_1 \\sigma_2 \\\\ & = x^2 + 2 y^2 + z^2 + \\sqrt{(x^2 + 2 y^2 + z^2)^2 - ((x^2 + 2 y^2 + z^2)^2 - 4 (y^2 - xz)^2)} \\\\ & = x^2 + 2 y^2 + z^2 + \\sqrt{4 (y^2 - xz)^2} \\\\ & = x^2 + 2 y^2 + z^2 + 2 |y^2 - xz| \\\\ & = \\begin{cases} (x + z)^2 & xz \\ge y^2 \\\\ (x - z)^2 + 4 y^2 & xz 　　现将xoz平面顺时针旋转45度，于是新的坐标满足 \\begin{align*} \\begin{bmatrix} x' \\\\ z' \\end{bmatrix} = \\begin{bmatrix} \\cos 45^\\circ & - \\sin 45^\\circ \\\\ \\sin 45^\\circ & \\cos 45^\\circ \\end{bmatrix} \\begin{bmatrix} x \\\\ z \\end{bmatrix} = \\frac{\\sqrt{2}}{2} \\begin{bmatrix} x - z \\\\ x + z \\end{bmatrix}, \\quad \\begin{bmatrix} x \\\\ z \\end{bmatrix} = \\begin{bmatrix} \\cos 45^\\circ & \\sin 45^\\circ \\\\ - \\sin 45^\\circ & \\cos 45^\\circ \\end{bmatrix} \\begin{bmatrix} x' \\\\ z' \\end{bmatrix} = \\frac{\\sqrt{2}}{2} \\begin{bmatrix} z' + x' \\\\ z' - x' \\end{bmatrix} \\end{align*} 注意xz = (z'^2 - x'^2) / 2，故核范数球边界在x'yz'坐标系下的方程为 \\begin{align*} 1 = \\begin{cases} 2 z'^2 & z'^2 - x'^2 \\ge 2 y^2 \\\\ 2 x'^2 + 4 y^2 & z'^2 - x'^2 1 = 2 z'^2对应两个平行的平面z' = \\pm 1 / \\sqrt{2}，核范数球边界在这两个平面上的边界为 \\begin{align*} z'^2 - x'^2 = 2 y^2 \\Longrightarrow 2 x'^2 + 4 y^2 = 1 \\end{align*} 是一个长轴为1 / \\sqrt{2}、短轴为1/2的椭圆。再看第二行，注意 \\begin{align*} z'^2 z' = \\pm 1 / \\sqrt{2}之间的一系列椭圆2 x'^2 + 4 y^2 = 1。 　　综上，\\Sbb_2的核范数球在x'yz'坐标系下为一个以z轴为中心的椭圆柱 \\begin{align*} 2 x'^2 + 4 y^2 \\le 1, \\quad - \\frac{1}{\\sqrt{2}} \\le z \\le \\frac{1}{\\sqrt{2}} \\end{align*} 将其沿xoz平面顺时针旋转45度，即为其在原xyz坐标系下的样子。 Copyright © Avanti 2020 all right reserved，powered by Gitbook文件最后修改时间： 2021-06-19 10:20:29 "},"posts/determinant/Cauchy-Binet.html":{"url":"posts/determinant/Cauchy-Binet.html","title":"柯西-比内公式","keywords":"","body":"　　众所周知对于方阵\\Av、\\Bv有 \\begin{align} \\label{eq: det-product} \\det(\\Av \\Bv) = \\det(\\Av) \\det(\\Bv) \\end{align} 更一般的设\\Av \\in \\Rbb^{m \\times n}、\\Bv \\in \\Rbb^{n \\times m}，记S_{[n],m}为集合[n]的所有m元子集构成的集合，则 \\begin{align} \\label{eq: Cauchy-Binet} \\det(\\Av \\Bv) = \\sum_{S \\in S_{[n],m}} \\det(\\Av_{[m],S}) \\det(\\Bv_{S,[m]}) \\end{align} 这就是Cauchy-Binet公式。 　　考虑三种情况： m = n，此时S_{[n],n}中只有一个元素，就是[n]，式(\\ref{eq: Cauchy-Binet})就退化成了式(\\ref{eq: det-product})； m > n，此时S_{[n],m}是个空集，因此式(\\ref{eq: Cauchy-Binet})等号右边的求和为零，而左边是个秩为n的m阶方阵，非满秩矩阵对应的行列式值为零； m ，举个简单的例子，n=3、m=2、S_{[n],m} = \\{ \\{1,2\\}, \\{2,3\\}, \\{1,3\\} \\}，此时有 \\begin{align*} \\left| \\begin{bmatrix} a_{11} & a_{12} & a_{13} \\\\ a_{21} & a_{22} & a_{23} \\end{bmatrix} \\begin{bmatrix} b_{11} & b_{12} \\\\ b_{21} & b_{22} \\\\ b_{31} & b_{32} \\end{bmatrix} \\right| = \\underbrace{\\left| \\begin{matrix} a_{11} & a_{12} \\\\ a_{21} & a_{22} \\end{matrix} \\right| \\left| \\begin{matrix} b_{11} & b_{12} \\\\ b_{21} & b_{22} \\end{matrix} \\right|}_{S=\\{1,2\\}} + \\underbrace{\\left| \\begin{matrix} a_{12} & a_{13} \\\\ a_{22} & a_{23} \\end{matrix} \\right| \\left| \\begin{matrix} b_{21} & b_{22} \\\\ b_{31} & b_{32} \\end{matrix} \\right|}_{S=\\{2,3\\}} + \\underbrace{\\left| \\begin{matrix} a_{11} & a_{13} \\\\ a_{21} & a_{23} \\end{matrix} \\right| \\left| \\begin{matrix} b_{11} & b_{12} \\\\ b_{31} & b_{32} \\end{matrix} \\right|}_{S=\\{1,3\\}} \\end{align*} 　　下面给出一个简单的证明，记\\Av的列分别为\\av_1, \\ldots, \\av_n，则 \\begin{align*} \\Av \\Bv = \\begin{bmatrix} \\sum_i b_{i1} \\av_i & \\sum_i b_{i2} \\av_i & \\ldots & \\sum_i b_{im} \\av_i \\end{bmatrix} \\end{align*} 即\\Av \\Bv的每一列都是\\av_1, \\ldots, \\av_n的线性组合。下面依次展开每一列，易知 \\begin{align*} \\det(\\Av \\Bv) & = | \\begin{matrix} \\sum_i b_{i1} \\av_i & \\sum_i b_{i2} \\av_i & \\ldots & \\sum_i b_{im} \\av_i \\end{matrix} | \\\\ & = b_{11} | \\begin{matrix} \\av_1 & \\sum_i b_{i2} \\av_i & \\ldots & \\sum_i b_{im} \\av_i \\end{matrix} | + \\cdots + b_{n1} | \\begin{matrix} \\av_n & \\sum_i b_{i2} \\av_i & \\ldots & \\sum_i b_{im} \\av_i \\end{matrix} | \\end{align*} 接着展开第二列，易知上式右边的每一项又会拆分成n项，即 \\begin{align*} \\forall k \\in [n], \\quad & b_{k1} | \\begin{matrix} \\av_k & \\sum_i b_{i2} \\av_i & \\ldots & \\sum_i b_{im} \\av_i \\end{matrix} | = b_{k1} (b_{12} | \\begin{matrix} \\av_k & \\av_1 & \\ldots & \\sum_i b_{im} \\av_i \\end{matrix} | + \\cdots + b_{n2} | \\begin{matrix} \\av_k & \\av_n & \\ldots & \\sum_i b_{im} \\av_i \\end{matrix} |) \\end{align*} 最终全部m列展开完毕，将会得到n^m项： \\begin{align*} \\det(\\Av \\Bv) = \\sum_{\\phi} b_{\\phi(1),1} b_{\\phi(2),2} \\cdots b_{\\phi(m),m} | \\begin{matrix} \\av_{\\phi(1)} & \\av_{\\phi(2)} & \\ldots & \\av_{\\phi(m)} \\end{matrix} | \\end{align*} 其中\\phi是[m] \\mapsto [n]的映射，求和遍历所有这样的映射。注意若行列式两列相同，行列式值为零，因此实际我们只需考虑单射，这样上式的求和项中就只剩下A_n^m项。 　　对于任一满足\\phi(1) 的项，显然它的行列式中的部分是\\Av的某个m阶子方阵，故 \\begin{align*} | \\begin{matrix} \\av_{\\phi(1)} & \\av_{\\phi(2)} & \\ldots & \\av_{\\phi(m)} \\end{matrix} | = \\det(\\Av_{[m], S}) \\end{align*} 其中S = \\{\\phi(1), \\phi(2), \\ldots, \\phi(m)\\}。现考虑其它行列式也由\\av_{\\phi(1)}, \\ldots, \\av_{\\phi(m)}构成的项，这样的项有m!个，均呈型 \\begin{align*} b_{\\sigma \\circ \\phi(1),1} b_{\\sigma \\circ \\phi(2),2} \\cdots b_{\\sigma \\circ \\phi(m),m} | \\begin{matrix} \\av_{\\sigma \\circ \\phi(1)} & \\av_{\\sigma \\circ \\phi(2)} & \\ldots & \\av_{\\sigma \\circ \\phi(m)} \\end{matrix} | \\end{align*} 其中\\sigma是S \\mapsto S的置换，由于行列式交换两列，值不变符号取反，因此 \\begin{align*} | \\begin{matrix} \\av_{\\sigma \\circ \\phi(1)} & \\av_{\\sigma \\circ \\phi(2)} & \\ldots & \\av_{\\sigma \\circ \\phi(m)} \\end{matrix} | = (-1)^{\\sgn (\\sigma)} | \\begin{matrix} \\av_{\\phi(1)} & \\av_{\\phi(2)} & \\ldots & \\av_{\\phi(m)} \\end{matrix} | = (-1)^{\\sgn (\\sigma)} \\det(\\Av_{[m], S}) \\end{align*} 其中\\sgn (\\sigma)是\\sigma产生的逆序对的个数。所有这样的项求和为 \\begin{align*} \\left( \\sum_{\\sigma} (-1)^{\\sgn (\\sigma)} b_{\\sigma \\circ \\phi(1),1} b_{\\sigma \\circ \\phi(2),2} \\cdots b_{\\sigma \\circ \\phi(m),m} \\right) \\det(\\Av_{[m], S}) \\end{align*} 注意括号中的部分就是\\Bv的第\\phi(1), \\ldots, \\phi(m)行构成的m阶子方阵的行列式展开，因此上式等于 \\begin{align*} \\det(\\Av_{[m], S}) \\det(\\Bv_{S,[m]}) \\end{align*} 取遍C_n^m个这样单调递增的\\phi即可得 \\begin{align*} \\det(\\Av \\Bv) = \\sum_{S \\in S_{[n],m}} \\det(\\Av_{[m],S}) \\det(\\Bv_{S,[m]}) \\end{align*} Copyright © Avanti 2020 all right reserved，powered by Gitbook文件最后修改时间： 2021-06-19 10:20:29 "},"posts/measure/set-algebra.html":{"url":"posts/measure/set-algebra.html","title":"集合代数","keywords":"","body":"　　对于定积分 \\begin{align*} \\int_a^b f(x) \\diff x \\end{align*} Riemann积分对定义域区间[a,b]进行切分a = a_0 ，然后用上和 \\begin{align*} US = \\sum_{i \\in [n]} \\sup \\{ f(x): x \\in [a_{i-1}, a_i] \\} (a_i - a_{i-1}) \\end{align*} 与下和 \\begin{align*} LS = \\sum_{i \\in [n]} \\inf \\{ f(x): x \\in [a_{i-1}, a_i] \\} (a_i - a_{i-1}) \\end{align*} 对积分值进行夹逼 \\begin{align*} LS \\leq \\int_a^b f(x) \\diff x \\leq US \\end{align*} 　　随着切分越来越细，上和单调减，下和单调增，当积分函数f连续时，两者极限相等且等于积分值，但是当f(非常)不连续时，Riemann积分就会出问题了，比如对Dirichlet函数 \\begin{align*} f(x) = \\begin{cases} 1 & x \\in \\Qbb \\\\ 0 & \\ow \\end{cases} \\end{align*} 无论怎么对定义域切分，下和总是0，上和总是1，极限不相等。为了解决此类问题，Lebesgue积分采用对值域进行切分的方式，对于某个值域区间[a, b]，易知也有上和、下和夹逼： \\begin{align*} \\int_{x\\in\\{ a \\leq f(x) \\leq b \\}} a \\diff x \\leq \\int_{x\\in\\{ a \\leq f(x) \\leq b \\}} f(x) \\diff x \\leq \\int_{x\\in\\{ a \\leq f(x) \\leq b \\}} b \\diff x \\end{align*} 于是问题就转化为求集合\\{x : a \\leq f(x) \\leq b \\}的“长度”。 　　给集合赋予“长度”是Lebesgue测度论的核心问题，这个问题看似简单，其实很复杂，因为集合可能是无穷点集(上面Dirichlet函数的例子)，也可能是无穷个不相交小区间的并集(在(0,1]上对\\sin (1/x)积分)。事实上，不存在一个普适的长度函数能够对\\Rbb的任意子集都赋予长度，总有些稀奇古怪的异类需要剔除，因此我们引入集合代数的概念，通过定义一些规则，导出一类性质良好可以赋予长度的集合。 　　设\\Omega为非空集合，\\Acal \\subseteq \\Pcal(\\Omega)为其子集构成的集合，对前面的一维积分问题，\\Omega就是\\Rbb，但测度论并不局限于一维积分。例如对n维积分，\\Omega是\\Rbb^n；对概率论，\\Omega是基础事件集合。因此为了保持结论的一般性，我们不将全集写为\\Rbb。 　　集合代数中最简单的结构是环(ring)，其满足三个条件：(1).\\emptyset \\subseteq \\Acal；(2).\\Acal关于\\setminus封闭；(3).\\Acal关于\\cup封闭。这个名字不是随便乱起的，因为定义加法为对称差\\Delta、乘法为交\\cap，(\\Acal, \\Delta, \\cap)就构成了抽象代数里的(交换)环，具体可参见此文。 　　若将环的后两个条件弱化可得到半环(semiring)，其满足：(1).\\emptyset \\subseteq \\Acal；(2).对于\\forall A, B \\in \\Acal，A \\setminus B是\\Acal中有限个不相交集合的并；(3).\\Acal关于\\cap封闭。 　　由于\\cup封闭可保证半环的第二个条件始终满足，而\\setminus封闭可导出\\cap封闭： \\begin{align*} X \\setminus (X \\setminus Y) = X \\setminus (X \\cap \\complement Y) = X \\cap \\complement (X \\cap \\complement Y) = X \\cap (\\complement X \\cup Y) = X \\cap Y \\end{align*} 因此环肯定是半环。但反过来不成立，例如\\Rbb上的全部左开右闭区间构成的集合 \\begin{align*} \\Acal = \\{ (a,b] \\mid a,b \\in \\Rbb, a \\leq b \\} \\end{align*} 就是一个半环，但不是环(关于\\cup不封闭)。事实上，如果半环关于\\cup封闭，则结合第二个条件“A \\setminus B是\\Acal中有限个不相交集合的并”可导出“A \\setminus B是\\Acal中元素”，即关于\\setminus封闭，半环升级成环。 　　若将环的第一个条件改成全集\\Omega \\in \\Acal，则得到代数(algebra)，其满足：(1).\\Omega \\subseteq \\Acal；(2).\\Acal关于\\setminus封闭；(3).\\Acal关于\\cup封闭。 　　由于\\emptyset = (\\Omega \\setminus \\Omega) \\in \\Acal，因此代数肯定是环，但反过来不成立，例如\\Rbb上的全部有界区间的有限并(finite unions)构成的集合就是一个环，但不是代数(全集\\Omega = \\Rbb不属于该集合，因为它无法写成有界区间的有限并)。更一般的，设全集为不可数集合，则其所有可数子集构成的集合就只是环而不是代数。环升级成代数的方法也很简单：先加入全集，然后加入必要的保证\\setminus、\\cup封闭的新元素即可。 　　由于全集的存在，\\setminus封闭可导出\\complement封闭，而由De Morgan律： \\begin{align*} X \\cap Y & = \\complement \\complement (X \\cap Y) = \\complement (\\complement X \\cup \\complement Y) \\\\ X \\cup Y & = \\complement \\complement (X \\cup Y) = \\complement (\\complement X \\cap \\complement Y) \\end{align*} 即在\\complement封闭的前提下，\\cap封闭、\\cup封闭可以互推。又A \\setminus B = A \\cap \\complement B，因此\\cap、\\complement封闭可以导出\\setminus封闭，于是若全集存在，则有 \\begin{align*} \\setminus, \\cup \\text{封闭} \\Longleftrightarrow \\complement, \\cap \\text{封闭} \\Longleftrightarrow \\complement, \\cup \\text{封闭} \\end{align*} 故代数也可等价定义为：(1).\\Omega \\subseteq \\Acal；(2).\\Acal关于\\complement封闭；(3).\\Acal关于\\cap或\\cup封闭。 　　虽然环以\\Delta为加法、\\cap为乘法可构成抽象代数里的交换环(该方式也是唯一的)，但是代数以\\Delta为加法、\\cap为乘法却没有对应的抽象代数结构，易知 \\begin{align*} A \\cap \\Omega = A, \\quad A \\cap \\emptyset = \\emptyset \\end{align*} 即全集\\Omega是乘法运算的单位元，空集\\emptyset是乘法运算的零元(这是环就有的)，但其它非零元素没有乘法逆元，设A \\in \\Acal为非空集，显然不存在其它集合与A的交集等于全集(单位元)，因此代数无法构成抽象代数里的域。 　　前面提到在(0,1]上对\\sin (1/x)积分时，集合\\{x : a \\leq f(x) \\leq b \\}是无穷个不相交小区间的并集，因此我们也要允许可数次并这样的操作，这样就导出了\\sigma-环，其满足：(1).\\emptyset \\subseteq \\Acal；(2).\\Acal关于\\setminus封闭；(3).\\Acal关于可数次\\cup封闭；以及\\sigma-代数，其满足：(1).\\Omega \\subseteq \\Acal；(2).\\Acal关于\\setminus封闭；(3).\\Acal关于可数次\\cup封闭。\\sigma-代数也被称为\\sigma-域，但前文表明代数并不对应抽象代数里的域，因此我不喜欢这样的叫法，容易产生误解。\\sigma-环、\\sigma-代数的关系与环、代数的关系一样，前者加入全集，然后再加入必要的保证\\setminus、\\cup封闭的新元素即可得到后者。 　　综上，半环、环、代数、\\sigma-环、\\sigma-代数之间的关系如下： 　　测度论一般采用\\sigma-代数作为考虑对象，即对\\sigma-代数中的任一集合赋予长度。具体到一维积分，这意味着全集\\Rbb是有长度的，若A \\subseteq \\Rbb是\\sigma-代数中的集合，即可以赋予长度，那么\\Rbb \\setminus A也是可以赋予长度的，若A_1, A_2, \\ldots可以赋予长度，那么其并集也可以赋予长度。 　　采用别的结构作为基础建立测度论也不是不可以，只是没有\\sigma-代数那么好用。比如函数f可测的定义是对任意Borel集B \\subseteq \\Rbb，逆象f^{-1} (B) \\in \\Sigma，其中\\Sigma是一个\\sigma-代数。若在\\sigma-环\\Sigma_r上沿用此定义，即对任意Borel集B \\subseteq \\Rbb有f^{-1} (B) \\in \\Sigma_r。由于全集\\Omega = f^{-1} (\\Rbb)，因此要么\\Sigma_r包含全集从而是一个\\sigma-代数，要么任何函数都不可测。若修正定义为对任意Borel集B \\subseteq \\Rbb有\\{ x: f(x) \\neq 0 \\} \\cap f^{-1}(B) \\in \\Sigma_r，此时可避免所有函数不可测的情况，因为即便B = \\Rbb，即f^{-1}(B) = \\Omega，第一项可能会小于全集。但是注意到对任意非零常数函数f，均有\\{ x: f(x) \\neq 0 \\} = \\Omega，因此所有的非零常数函数都是不可测的，进一步这会导出即便f可测，f+1也还是不可测这样反直觉的结果。 Copyright © Avanti 2020 all right reserved，powered by Gitbook文件最后修改时间： 2021-06-19 10:20:29 "},"posts/measure/set-ring-algebra-ring.html":{"url":"posts/measure/set-ring-algebra-ring.html","title":"此环非彼环乎？","keywords":"","body":"　　学测度论时会碰到某个非空集合\\Omega的子集构成的集合\\Acal \\subseteq \\Pcal(\\Omega)，当其满足(1).\\emptyset \\subseteq \\Acal；(2).\\Acal关于\\setminus封闭；(3).\\Acal关于\\cup封闭，称为环(ring)。众所周知抽象代数里有个数学结构也叫环，其上定义了加法、乘法两个二元运算，并且关于加法构成交换群(commutative group)，关于乘法构成半群(semigroup)，乘法对加法满足分配律。 　　为了区别，下面我们称前者为集合环，后者为代数环。本文说明两者的关系是\\Acal能通过赋予合适的集合上的加法、乘法构成代数(交换)环当且仅当\\Acal是集合环。 　　\\Leftarrow较为简单，给出具体的加法、乘法定义再验证满足代数环公理即可。定义集合环\\Acal中的加法为对称差： \\begin{align*} X \\Delta Y = (X \\setminus Y) \\cup (Y \\setminus X), \\quad \\forall X, Y \\in \\Acal \\end{align*} 不难验证(\\Acal, \\Delta)构成交换群，其中交换律是显然的，封闭性由集合环关于\\setminus、\\cup封闭保证，又 \\begin{align*} X \\Delta \\emptyset & = (X \\setminus \\emptyset) \\cup (\\emptyset \\setminus X) = X \\\\ X \\Delta X & = (X \\setminus X) \\cup (X \\setminus X) = \\emptyset \\end{align*} 因此\\emptyset是单位元，逆元就是自身，结合律(X \\Delta Y) \\Delta Z = X \\Delta (Y \\Delta Z)通过集合运算进行验证较为繁琐，根据下面的Venn图易知其成立。 　　定义乘法为\\cap，于是交换律、结合律都是显然的，由于X \\setminus Y = X \\cap \\complement Y，因此 \\begin{align*} X \\setminus (X \\setminus Y) = X \\setminus (X \\cap \\complement Y) = X \\cap \\complement (X \\cap \\complement Y) = X \\cap (\\complement X \\cup Y) = X \\cap Y \\end{align*} 即封闭性也是满足的(这也说明集合环关于\\cup、\\cap、\\setminus都是封闭的)。 　　最后验证\\Delta对于\\cap满足分配律，由于 \\begin{align*} X \\Delta Y = (X \\setminus Y) \\cup (Y \\setminus X) = (X \\cap \\complement Y) \\cup (Y \\cap \\complement X) = (X \\cup Y) \\cap (\\complement X \\cup \\complement Y) \\end{align*} 于是 \\begin{align*} (X \\Delta Y) \\cap Z & = (X \\cup Y) \\cap (\\complement X \\cup \\complement Y) \\cap Z \\\\ & = (X \\cup Y) \\cap (\\complement X \\cup \\complement Y \\cup \\complement Z) \\cap Z \\\\ & = [(X \\cup Y) \\cap Z] \\cap [\\complement X \\cup \\complement Y \\cup \\complement Z] \\\\ & = [(X \\cap Z) \\cup (Y \\cap Z)] \\cap [\\complement (X \\cap Z) \\cup \\complement(Y \\cap Z)] \\\\ & = (X \\cap Z) \\Delta (Y \\cap Z) \\end{align*} 同理易知有 \\begin{align*} Z \\cap (X \\Delta Y) = Z \\cap (X \\cup Y) \\cap (\\complement X \\cup \\complement Y) = (X \\cap Z) \\Delta (Y \\cap Z) = (Z \\cap X) \\Delta (Z \\cap Y) \\end{align*} 综上，若\\Acal \\subseteq \\Pcal(\\Omega)是集合环，则(\\Acal, \\Delta, \\cap)构成代数(交换)环。 　　\\Rightarrow较为复杂，因为我们不知道一个有望构成交换环的集合，它对应的加法、乘法分别是啥，所以我们得先把加法、乘法构造出来。 　　先考虑二元集合R = \\{0, 1\\}构成的交换环(R, +, \\times)，不妨设加法单位元是0，由交换律可知 \\begin{align*} 0 + 0 = 0, \\quad 0 + 1 = 1 + 0 = 1 \\end{align*} 若1 + 1 = 1，则1没有逆元，故1 + 1 = 0，不难验证这样定义的(R, +)构成交换群。由于\\times对+满足分配律，因此 \\begin{align*} 0 \\times 0 = (0 + 0) \\times 0 = 0 \\times 0 + 0 \\times 0 & \\Longrightarrow 0 \\times 0 = 0 \\\\ 0 \\times 1 = (0 + 0) \\times 1 = 0 \\times 1 + 0 \\times 1 & \\Longrightarrow 0 \\times 1 = 0 \\\\ 1 \\times 0 = 1 \\times (0 + 0) = 1 \\times 0 + 1 \\times 0 & \\Longrightarrow 1 \\times 0 = 0 \\end{align*} 最后1 \\times 1无论等于0还是1，(R, \\times)均可构成半群。因此二元集合可构成两种环，加法均为 \\begin{align*} 0 + 0 = 0, \\quad 0 + 1 = 1 + 0 = 1, \\quad 1 + 1 = 0 \\\\ \\end{align*} 乘法分别为 \\begin{align*} 0 \\times 0 = 0, \\quad 0 \\times 1 = 1 \\times 0 = 0, \\quad 1 \\times 1 = 0 \\\\ 0 \\times 0 = 0, \\quad 0 \\times 1 = 1 \\times 0 = 0, \\quad 1 \\times 1 = 1 \\end{align*} 即只在1 \\times 1的结果上有区别。若加法单位元是1，上述所有运算结果的0和1互换位置，整体结构不变。 　　设R^\\Omega = \\{ f: \\Omega \\mapsto R \\}，由R的特性知每个f都是将\\Omega中的一部分元素映射为0，剩下映射为1，因此R^\\Omega中共有|\\Pcal(\\Omega)|个元素，每个元素均是\\Omega某个子集的特征函数： \\begin{align*} R^\\Omega = \\{ 1_X \\mid X \\in \\Pcal(\\Omega) \\} \\end{align*} 这样就在R^\\Omega和\\Pcal(\\Omega)间建立了一一对应，即g: 1_X \\mapsto X是一个双射。若R^\\Omega想构成环，其上的加法、乘法只能由R上的加法、乘法导出： \\begin{align*} \\oplus: ~ & (1_X,1_Y) \\mapsto (1_X \\oplus 1_Y) (a) \\triangleq 1_X(a) + 1_Y(a) \\\\ \\otimes: ~ & (1_X,1_Y) \\mapsto (1_X \\otimes 1_Y) (a) \\triangleq 1_X(a) \\times 1_Y(a) \\end{align*} 　　根据R上的加法规则有 \\begin{align*} \\oplus: ~ & (1_X,1_Y) \\mapsto (1_X \\oplus 1_Y) (a) = \\begin{cases} 0 + 0 = 0 & \\forall a \\in \\Omega \\setminus (X \\cup Y) \\\\ 1 + 0 = 1 & \\forall a \\in X \\setminus Y \\\\ 0 + 1 = 1 & \\forall a \\in Y \\setminus X \\\\ 1 + 1 = 0 & \\forall a \\in X \\cap Y \\end{cases} \\end{align*} 即R^\\Omega上的加法规则为 \\begin{align*} (1_X,1_Y) \\mapsto 1_X \\oplus 1_Y = 1_{X \\Delta Y} \\end{align*} 两个集合的特征函数的加和等于其对称差的特征函数。R上的乘法规则不唯一 \\begin{align*} \\otimes: ~ & (1_X,1_Y) \\mapsto (1_X \\otimes 1_Y) (a) = \\begin{cases} 0 \\times 0 = 0 & \\forall a \\in \\Omega \\setminus (X \\cup Y) \\\\ 1 \\times 0 = 0 & \\forall a \\in X \\setminus Y \\\\ 0 \\times 1 = 0 & \\forall a \\in Y \\setminus X \\\\ 1 \\times 1 = 0~\\text{或}~1 & \\forall a \\in X \\cap Y \\end{cases} \\end{align*} 前者对应任何两个集合的特征函数的乘积都是空集的特征函数，后者对应乘积是交集的特征函数： \\begin{align*} (1_X,1_Y) \\mapsto 1_X \\otimes 1_Y = 1_\\emptyset ~\\text{或}~ 1_{X \\cap Y} \\end{align*} 　　若R上的加法单位元是1，运算规则中的0和1互换位置，因此导出的R^\\Omega上的加法规则为 \\begin{align*} (1_X,1_Y) \\mapsto 1_X \\oplus 1_Y = 1_{\\complement (X \\Delta Y)} \\end{align*} 同样乘法规则不唯一，其中一个对应任何两个集合的乘积都是全集的特征函数，另一个对应乘积是交集的补集的特征函数，即 \\begin{align*} (1_X,1_Y) \\mapsto 1_X \\otimes 1_Y = 1_\\Omega ~\\text{或}~ 1_{\\complement (X \\cap Y)} \\end{align*} 即在前者的基础上多个取补集的操作(空集的补集是全集)。 　　至此给出了R^\\Omega可能构成的四种交换环 \\begin{align*} & (R^\\Omega, 1_X \\oplus 1_Y = 1_{X \\Delta Y}, 1_X \\otimes 1_Y = 1_\\emptyset) \\\\ & (R^\\Omega, 1_X \\oplus 1_Y = 1_{X \\Delta Y}, 1_X \\otimes 1_Y = 1_{X \\cap Y}) \\\\ & (R^\\Omega, 1_X \\oplus 1_Y = 1_{\\complement (X \\Delta Y)}, 1_X \\otimes 1_Y = 1_\\Omega) \\\\ & (R^\\Omega, 1_X \\oplus 1_Y = 1_{\\complement (X \\Delta Y)}, 1_X \\otimes 1_Y = 1_{\\complement (X \\cap Y)}) \\end{align*} 注意对于第二种交换环有 \\begin{align*} g(1_X \\oplus 1_Y) & = g(1_{X \\Delta Y}) = X \\Delta Y = g(1_X) \\Delta g(1_Y) \\\\ g(1_X \\otimes 1_Y) & = g(1_{X \\cap Y}) = X \\cap Y = g(1_X) \\cap g(1_Y) \\end{align*} 即(\\Pcal(\\Omega), \\Delta, \\cap)同构于(R^\\Omega, \\oplus, \\otimes)，也构成交换环，其他情形没有如此简洁的对应(常用的二元集合运算没有结果恒为空集、全集或两者对称差、交集的补集，除非重新定义)。 　　对\\forall \\Acal \\subseteq \\Pcal(\\Omega)，若其能够构成代数环，则(\\Acal, \\Delta, \\cap)应为(\\Pcal(\\Omega), \\Delta, \\cap)的子环，即\\Acal对\\Delta、\\cap保持封闭，于是对\\forall X, Y \\in \\Acal有 \\begin{align*} \\emptyset & = X \\Delta X \\in \\Acal \\\\ X \\setminus Y & = (X \\Delta Y) \\cap X \\in \\Acal \\\\ X \\cup Y & = (X \\Delta Y) \\Delta (X \\cap Y) \\in \\Acal \\end{align*} 因此\\Acal是集合环。 Copyright © Avanti 2020 all right reserved，powered by Gitbook文件最后修改时间： 2021-06-19 10:20:29 "},"posts/measure/interval.html":{"url":"posts/measure/interval.html","title":"区间","keywords":"","body":"　　Lebesgue积分的核心问题是给\\Rbb的子集赋予“长度”，而\\Rbb上最简单的子集就是区间，故从区间入手不失为一种途径。 　　区间是拥有凸性的一类子集，共有10种： \\begin{align*} (a,b), \\quad [a,b), \\quad (a,b], \\quad [a,b], \\quad (a,\\infty), \\quad [a,\\infty), \\quad (-\\infty,a), \\quad (-\\infty,a], \\quad (-\\infty, \\infty), \\quad \\emptyset \\end{align*} 其中\\Rbb = (-\\infty, \\infty)就是全集，\\emptyset是其补集，此外[a,a] = \\{ a \\}，因此单点集也属于区间。 　　对任意两个区间I_1、I_2，其交集是一个区间(\\emptyset也是区间)；其并集要么是一个区间，要么存在t满足如下两种情况之一：(1).对\\forall x_1 \\in I_1、\\forall x_2 \\in I_2有x_1 ；(2).对\\forall x_1 \\in I_1、\\forall x_2 \\in I_2有x_2 ；其补集要么是一个区间，要么是两个区间的并集。 　　下面考虑所有由区间的有限并(finite union)构成的集合\\Ical，不难验证\\Ical是一个代数。首先全集\\Rbb = (-\\infty, \\infty) \\in \\Ical；设E_1 = \\cup_{j \\in [n]} I_j \\in \\Ical，E_2 = \\cup_{k \\in [n']} I'_k \\in \\Ical，那么E_1 \\cup E_2显然还是区间的有限并；又 \\begin{align*} E_1 \\cap E_2 = (\\cup_{j \\in [n]} I_j) \\cap (\\cup_{k \\in [n']} I'_k) = \\cup_{j \\in [n]} \\cup_{k \\in [n']} (I_j \\cap I'_k) \\end{align*} 由于I_j \\cap I'_k是一个区间，因此E_1 \\cap E_2也是区间的有限并，从而属于\\Ical，最后由De Morgan律知\\complement E_1 = \\cap_{j \\in [n]} \\complement I_j，而每个\\complement I_j均是区间的有限并，因此其交集也属于\\Ical，故\\Ical是一个代数。 　　对于\\Ical中任一元素E，将能合并成一个区间的都合并掉，则可得到标准形式 \\begin{align*} E = I_1 \\cup \\cdots \\cup I_n \\end{align*} 其中I_1, \\ldots, I_n两两交集为空，且存在t_1, \\ldots, t_{n-1}满足 \\begin{align*} x_1 \\Ical中的任一写成该形式的元素默认为其标准形式。 　　下面考虑给区间赋予长度，直觉上来说区间长度就是其端点的差值，无界区间长度为\\infty，不相交区间的并的长度是它们的长度之和，故引入长度函数m: \\Ical \\mapsto [0, \\infty]： \\begin{align*} & m((a,b)) = m([a,b)) = m((a,b]) = m([a,b]) = b - a, \\quad m(\\emptyset) = 0 \\\\ & m((a,\\infty)) = m([a,\\infty)) = m((-\\infty,a)) = m((-\\infty,a]) = m((-\\infty, \\infty)) = \\infty \\end{align*} 对任意E = I_1 \\cup \\cdots \\cup I_n \\in \\Ical，定义m(E) = \\sum_{j \\in [n]} m(I_j)。 　　上述定义的长度函数m: \\Ical \\mapsto [0, \\infty]满足 有限可加性：设E_1, E_2, \\ldots, E_n \\in \\Ical且两两不相交，则m(\\cup_{j \\in [n]} E_j) = \\sum_{j \\in [n]} m(E_j)； 单调性：设E_1, E_2 \\in \\Ical且E_1 \\subseteq E_2，则m(E_1) \\leq m(E_2)； 有限次可加性：设E_1, E_2, \\ldots \\in \\Ical，则m(\\cup_{j \\in [n]} E_j) \\leq \\sum_{j \\in [n]} m(E_j)； 可数可加性：设E_1, E_2, \\ldots \\in \\Ical且两两不相交，若\\cup_{j=1}^\\infty E_j \\in \\Ical，则m(\\cup_{j=1}^\\infty E_j) = \\sum_{j=1}^\\infty m(E_j)； 可数次可加性：设E_1, E_2, \\ldots \\in \\Ical，若\\cup_{j=1}^\\infty E_j \\in \\Ical，则m(\\cup_{j=1}^\\infty E_j) \\leq \\sum_{j=1}^\\infty m(E_j)； 平移不变性：对\\forall E \\in \\Ical和x_0 \\in \\Rbb，E + x_0 \\triangleq \\{ x + x_0 \\mid x \\in E \\} \\in \\Ical且m(E + x_0) = m(E)。 　　可数可加性、可数次可加性分别是有限可加性、有限次可加性的推广，令E_{n+1} = E_{n+2} = \\cdots = \\emptyset即可由前者导出后者。此外可数(次)可加性的前提是\\cup_{j=1}^\\infty E_j \\in \\Ical，否则m(\\cup_{j=1}^\\infty E_j)没有定义，但这并不要求\\Ical是一个\\sigma-代数。 证明： 只需证明两个集合的情况即可由数学归纳法知结论对任意自然数n都成立。设E_1 \\cup E_2 = \\cup_{j \\in [n']} I_j，则m(E_1 \\cup E_2) = \\sum_{j \\in [n']} m(I_j)。注意构成E_1的每个区间必然都属于某个I_j，故其标准形式为E_1 = \\cup_{j \\in [n']} (E_1 \\cap I_j)，即m(E_1) = \\sum_{j \\in [n']} m(E_1 \\cap I_j)，同理m(E_2) = \\sum_{j \\in [n']} m(E_2 \\cap I_j)，于是待证结论变成 \\begin{align*} \\sum_{j \\in [n']} m(I_j) = \\sum_{j \\in [n']} m(E_1 \\cap I_j) + \\sum_{j \\in [n']} m(E_2 \\cap I_j) \\end{align*} 即只需证m(I_j) = m(E_1 \\cap I_j) + m(E_2 \\cap I_j)。注意E_1 \\cap I_j、E_2 \\cap I_j不相交，因此其标准形式中的所有区间均两两不相交，又这些区间的并集是区间I_j，因此这些区间写成标准形式是首尾相连的(前一个区间的右端点等于后一个区间的左端点)，从而m(I_j) = m(E_1 \\cap I_j) + m(E_2 \\cap I_j)。 若E_1 \\subseteq E_2，则E_2 = E_1 \\cup (E_2 \\setminus E_1)且E_1 \\cap (E_2 \\setminus E_1) = \\emptyset，由有限可加性和长度函数的非负性知 \\begin{align*} m(E_2) = m(E_1) + m(E_2 \\setminus E_1) \\geq m(E_1) \\end{align*} 只需证明两个集合的情况即可由数学归纳法知结论对任意自然数n都成立。由于E_1 \\cup E_2 = E_1 \\cup (E_2 \\setminus E_1)且E_1 \\cap (E_2 \\setminus E_1) = \\emptyset，又(E_2 \\setminus E_1) \\subseteq E_2，由有限可加性和单调性知 \\begin{align*} m(E_1 \\cup E_2) = m(E_1) + m(E_2 \\setminus E_1) \\leq m(E_1) + m(E_2) \\end{align*} 由有限可加性的证明知只需考虑\\cup_{j=1}^\\infty E_j等于一个区间I的情况，设E_j = \\cup_{k \\in [n_j]} I_{j,k}，于是 \\begin{align*} I = E_1 \\cup E_2 \\cup \\cdots = I_{1,1} \\cup I_{1,2} \\cup \\cdots \\cup I_{1,n_1} \\cup I_{2,1} \\cup I_{2,2} \\cup \\cdots \\cup I_{2,n_2} \\cup I_{3,1} \\cup \\cdots \\end{align*} 由于E_1, E_2, \\ldots两两不相交，因此上式中的可数无穷项I_{j,k}均两两不相交，将其写成标准形式： \\begin{align*} I = I_1 \\cup I_2 \\cup \\cdots = \\cup_{k=1}^\\infty I_k \\end{align*} 注意m(E_j) = \\sum_{k \\in [n_j]} m(I_{j,k})，于是待证结论变成 \\begin{align*} m(I) = m(\\cup_{k=1}^\\infty I_k) = \\sum_{k=1}^\\infty m(I_k) \\end{align*} 对任意自然数n，由有限可加性和单调性知 \\begin{align*} \\sum_{k \\in [n]} m(I_k) = m(\\cup_{k \\in [n]} I_k) \\leq m(\\cup_{k=1}^\\infty I_k) = m(I) \\end{align*} 令n \\rightarrow \\infty可得\\sum_{k=1}^\\infty m(I_k) \\leq m(I)。 下面证明另一个方向，不妨设所有的I_k都是有界区间(否则若某个I_k无界，则I也无界，上式两边都是\\infty)，则对\\forall \\epsilon > 0，存在开区间J_k从外部充分逼近I_k，即I_k \\subseteq J_k且m(J_k) 。引入有界闭区间[a_0, b_0] \\subseteq I，于是 \\begin{align*} [a_0, b_0] \\subseteq I = \\cup_{k=1}^\\infty I_k \\subseteq \\cup_{k=1}^\\infty J_k \\end{align*} 即J_1, J_2, \\ldots是有界闭区间[a_0, b_0]的一个开覆盖(open cover)，由Heine-Borel定理知其存在有限子覆盖，不妨设子覆盖的下标集合是\\Ical'，于是由有限可加性和单调性知 \\begin{align*} a_0 - b_0 = m([a_0, b_0]) \\leq \\sum_{k \\in \\Ical'} m(J_k) I无界，可以选取[a_0, b_0]使得b_0 - a_0任意的大，而\\epsilon又可以任意的小，于是有\\sum_{k=1}^\\infty m(I_k) = \\infty = m(I)；若I有界，选取[a_0, b_0]从内部充分逼近I，即使得b_0 - a_0 > m(I) - \\epsilon，于是有 \\begin{align*} m(I) - \\epsilon \\epsilon可以任意的小，故m(I) \\leq \\sum_{k=1}^\\infty m(I_k)。 综上有m(\\cup_{k=1}^\\infty I_k) = m(I) = \\sum_{k=1}^\\infty m(I_k)。 令F_j = E_j \\setminus (\\cup_{k \\in [j-1]} E_k) \\subseteq E_j，易知F_1, F_2, \\ldots两两不相交且对任意自然数n有\\cup_{j \\in [n]} F_j = \\cup_{j \\in [n]} E_j，于是 \\begin{align*} m(\\cup_{j \\in [n]} E_j) = m(\\cup_{j \\in [n]} F_j) = \\sum_{j \\in [n]} m(F_j) \\leq \\sum_{j \\in [n]} m(E_j) \\end{align*} 令n \\rightarrow \\infty可知m(\\cup_{j=1}^\\infty E_j) \\leq \\sum_{j=1}^\\infty m(E_j)。 设E = \\cup_{j \\in [n]} I_j，则E + x_0 = \\cup_{j \\in [n]} (I_j + x_0)。若I_j有界，设其端点分别为a、b，则I_j + x_0依然有界且端点分别为a + x_0、b + x_0，于是m(I_j + x_0) = (b + x_0) - (a + x_0) = b - a = m(I_j)；若I_j无界，则I_j + x_0也无界(\\pm \\infty + x_0 = \\pm \\infty)，且m(I_j + x_0) = \\infty = m(I_j)，综上有m(E + x_0) = m(E)。 Copyright © Avanti 2020 all right reserved，powered by Gitbook文件最后修改时间： 2021-06-19 10:20:29 "},"posts/probability/beta-dirichlet-distribution.html":{"url":"posts/probability/beta-dirichlet-distribution.html","title":"贝塔分布和狄利克雷分布","keywords":"","body":"　　Euler在研究阶乘插值时引入了B函数(第一型积分)和\\Gamma函数(第二型积分)，且它们有关系： \\begin{align*} B(m,n) = \\int_0^1 x^{m-1} (1-x)^{n-1} \\diff x = \\frac{\\Gamma(m) \\Gamma(n)}{\\Gamma(m+n)} \\end{align*} 于是定义函数f_{m,n}: [0,1] \\mapsto \\Rbb如下： \\begin{align*} f_{m,n}(x) = \\frac{x^{m-1} (1-x)^{n-1}}{B(m,n)} = \\frac{\\Gamma(m+n)}{\\Gamma(m) \\Gamma(n)} x^{m-1} (1-x)^{n-1} \\end{align*} 易知其积分为1，故可以将其看成一个概率密度函数，由于这个函数的分母是B函数，我们称其对应的概率分布为参数为m、n的Beta分布。 　　下面给出Beta分布的数字特征，易知其k阶矩为 \\begin{align*} \\Ebb[x^k] & = \\int_0^1 x^k f_{m,n}(x) \\diff x = \\int_0^1 x^k \\frac{x^{m-1} (1-x)^{n-1}}{B(m,n)} \\diff x = \\frac{B(m+k,n)}{B(m,n)} \\int_0^1 \\frac{x^{m+k-1} (1-x)^{n-1}}{B(m+k, n)} \\diff x \\\\ & = \\frac{B(m+k, n)}{B(m,n)} = \\frac{\\Gamma(m+k) \\Gamma(n)}{\\Gamma(m+k+n)} / \\frac{\\Gamma(m) \\Gamma(n)}{\\Gamma(m+n)} = \\frac{\\Gamma(m+k) \\Gamma(m+n)}{\\Gamma(m+k+n) \\Gamma(m)} \\end{align*} 于是 \\begin{align*} \\Ebb[x] = \\frac{\\Gamma(m+1) \\Gamma(m+n)}{\\Gamma(m+1+n) \\Gamma(m)} = \\frac{m}{m+n}, \\quad \\Ebb[x^2] = \\frac{\\Gamma(m+2) \\Gamma(m+n)}{\\Gamma(m+2+n) \\Gamma(m)} = \\frac{(m+1)m}{(m+n+1)(m+n)} \\end{align*} 故其均值和方差分别为 \\begin{align*} \\Ebb[x] = \\frac{m}{m+n}, \\quad \\Vbb[x] = \\frac{(m+1)m}{(m+n+1)(m+n)} - \\left(\\frac{m}{m+n}\\right)^2 = \\frac{mn}{(m+n+1)(m+n)^2} \\end{align*} 　　B函数是二元的，可将其推广成到k+1元： \\begin{align} \\label{eq: multivariate beta function} B(m_1, \\ldots, m_{k+1}) = \\int_0^1 x_1^{m_1-1} \\int_0^{1-x_1} x_2^{m_2-1} \\cdots \\int_0^{1-x_1 - \\cdots - x_{k-1}} x_k^{m_k-1} (1 - x_1 - \\cdots - x_k)^{m_{k+1}-1} \\diff \\xv \\end{align} 注意式(\\ref{eq: multivariate beta function})是一个k重积分，考察最里面关于x_k的积分，即 \\begin{align*} E_k(m_k, m_{k+1}) = \\int_0^{1-x_1 - \\cdots - x_{k-1}} x_k^{m_k-1} (1 - x_1 - \\cdots - x_k)^{m_{k+1}-1} \\diff x_k = \\int_0^t x_k^{m_k-1} (t - x_k)^{m_{k+1}-1} \\diff x_k \\end{align*} 其中t = 1-x_1 - \\cdots - x_{k-1}。由分部积分有 \\begin{align*} E_k(m_k, m_{k+1}) & = \\frac{1}{m_k} \\int_0^t (t - x_k)^{m_{k+1}-1} \\diff x_k^{m_k} \\\\ & = \\left. \\frac{1}{m_k} (t - x_k)^{m_{k+1}-1} x_k^{m_k} \\right|_0^t + \\frac{1}{m_k} \\int_0^t x_k^{m_k} (m_{k+1}-1) (t - x_k)^{m_{k+1}-2} \\diff x_k \\\\ & = \\frac{m_{k+1}-1}{m_k} E_k(m_k+1, m_{k+1}-1) \\end{align*} 于是递推下去有 \\begin{align*} E_k(m_k, m_{k+1}) & = \\frac{m_{k+1}-1}{m_k} \\cdot \\frac{m_{k+1}-2}{m_k+1} E_k(m_k+2, m_{k+1}-2) \\\\ & = \\cdots \\\\ & = \\frac{m_{k+1}-1}{m_k} \\cdots \\frac{1}{m_k + m_{k+1} - 2} E_k(m_k + m_{k+1} - 1, 1) \\end{align*} 又 \\begin{align*} E_k(m_k + m_{k+1} - 1, 1) = \\int_0^t x_k^{m_k + m_{k+1} - 2} \\diff x_k = \\left. \\frac{x_k^{m_k + m_{k+1} - 1}}{m_k + m_{k+1} - 1} \\right|_0^t = \\frac{t^{m_k + m_{k+1} - 1}}{m_k + m_{k+1} - 1} \\end{align*} 于是 \\begin{align*} E_k(m_k, m_{k+1}) = \\frac{\\Gamma(m_{k+1}) \\Gamma(m_k)}{\\Gamma(m_{k+1} + m_k)} (1-x_1 - \\cdots - x_{k-1})^{m_k + m_{k+1} - 1} \\end{align*} 将其回代入式(\\ref{eq: multivariate beta function})，接着考察最里面关于x_{k-1}的积分 \\begin{align*} E_{k-1}(m_{k-1}, m_k + m_{k+1}) = \\frac{\\Gamma(m_{k+1}) \\Gamma(m_k)}{\\Gamma(m_{k+1} + m_k)} \\int_0^t x_{k-1}^{m_{k-1}-1} (t - x_{k-1})^{m_k + m_{k+1} - 1} \\diff x_{k-1} \\end{align*} 其中t = 1-x_1 - \\cdots - x_{k-2}。由分部积分有 \\begin{align*} E_{k-1}(m_{k-1}, m_k + m_{k+1}) & = \\frac{\\Gamma(m_{k+1}) \\Gamma(m_k)}{\\Gamma(m_{k+1} + m_k)} \\cdot \\frac{\\Gamma(m_{k+1} + m_k) \\Gamma(m_{k-1})}{\\Gamma(m_{k+1} + m_k + m_{k-1})} t^{m_{k+1} + m_k + m_{k-1} - 1} \\\\ & = \\frac{\\Gamma(m_{k+1}) \\Gamma(m_k) \\Gamma(m_{k-1})}{\\Gamma(m_{k+1} + m_k + m_{k-1})} (1-x_1 - \\cdots - x_{k-2})^{m_{k+1} + m_k + m_{k-1} - 1} \\end{align*} 不断重复这个过程可知 \\begin{align} \\label{eq: E2} E_2(m_2, m_{k+1} + m_k + \\cdots + m_3) = \\frac{\\Gamma(m_{k+1}) \\Gamma(m_k) \\cdots \\Gamma(m_2)}{\\Gamma(m_{k+1} + m_k + \\cdots + m_2)} (1-x_1)^{m_{k+1} + m_k + \\cdots + m_2 - 1} \\end{align} 于是最终对x_1积分可得 \\begin{align*} B(m_1, \\cdots, m_{k+1}) & = \\int_0^1 x_1^{m_1-1} \\frac{\\Gamma(m_{k+1}) \\Gamma(m_k) \\cdots \\Gamma(m_2)}{\\Gamma(m_{k+1} + m_k + \\cdots + m_2)} (1-x_1)^{m_{k+1} + m_k + \\cdots + m_2 - 1} \\diff x_1 \\\\ & = \\frac{\\Gamma(m_{k+1}) \\Gamma(m_k) \\cdots \\Gamma(m_2)}{\\Gamma(m_{k+1} + m_k + \\cdots + m_2)} \\cdot \\frac{\\Gamma(m_{k+1} + m_k + \\cdots + m_2) \\Gamma(m_1)}{\\Gamma(m_{k+1} + m_k + \\cdots + m_1)} 1^{m_{k+1} + m_k + \\cdots + m_1 - 1} \\\\ & = \\frac{\\Gamma(m_{k+1}) \\Gamma(m_k) \\cdots \\Gamma(m_1)}{\\Gamma(m_{k+1} + m_k + \\cdots + m_1)} \\end{align*} 记\\mv = [m_1; \\ldots; m_{k+1}]，\\xv = [x_1; \\ldots; x_{k+1}]，定义函数f_{\\mv}: \\Delta_{k+1} \\mapsto \\Rbb如下： \\begin{align*} f_{\\mv} (\\xv) = \\frac{\\Gamma(m_{k+1} + m_k + \\cdots + m_1)}{\\Gamma(m_{k+1}) \\Gamma(m_k) \\cdots \\Gamma(m_1)} \\prod_{i=1}^{k+1} x_i^{m_i - 1} \\end{align*} 由上面的推导可知f_{\\mv} (\\xv)的k重积分为1，故可以将其看成一个概率密度函数，们称其对应的概率分布为参数为\\mv的Dirichlet分布。 　　下面给出Dirichlet分布的数字特征，易知 \\begin{align*} & x_j^n f_{\\mv} (\\xv) = \\frac{\\Gamma(m_{k+1} + \\cdots + m_1)}{\\Gamma(m_{k+1}) \\cdots \\Gamma(m_1)} x_j^n \\prod_{i=1}^{k+1} x_i^{m_i - 1} \\\\ & = \\frac{\\Gamma(m_{k+1} + \\cdots + m_1)}{\\Gamma(m_{k+1} + \\cdots + m_j + n + \\cdots + m_1)} \\cdot \\frac{\\Gamma(m_j + n)}{\\Gamma(m_j)} \\cdot \\frac{\\Gamma(m_{k+1} + \\cdots + m_j + n + \\cdots + m_1)}{\\Gamma(m_{k+1}) \\cdots \\Gamma(m_j + n) \\cdots \\Gamma(m_1)} x_j^n \\prod_{i=1}^{k+1} x_i^{m_i - 1} \\end{align*} 于是 \\begin{align*} \\Ebb[x_j] & = \\frac{\\Gamma(m_{k+1} + \\cdots + m_1)}{\\Gamma(m_{k+1} + \\cdots + m_j + 1 + \\cdots + m_1)} \\frac{\\Gamma(m_j + 1)}{\\Gamma(m_j)} = \\frac{m_j}{m_{k+1} + \\cdots + m_1} \\\\ \\Ebb[x_j^2] & = \\frac{\\Gamma(m_{k+1} + \\cdots + m_1)}{\\Gamma(m_{k+1} + \\cdots + m_j + 2 + \\cdots + m_1)} \\frac{\\Gamma(m_j + 2)}{\\Gamma(m_j)} = \\frac{(m_j+1)m_j}{(m_{k+1} + \\cdots + m_1 + 1)(m_{k+1} + \\cdots + m_1)} \\end{align*} 故其均值和方差分别为 \\begin{align*} \\Ebb[x_j] & = \\frac{m_j}{m_{k+1} + \\cdots + m_1} \\\\ \\Vbb[x_j] & = \\frac{(m_j+1)m_j}{(m_{k+1} + \\cdots + m_1 + 1)(m_{k+1} + \\cdots + m_1)} - \\left(\\frac{m_j}{m_{k+1} + \\cdots + m_1}\\right)^2 \\\\ & = \\frac{m_j (m_{k+1} + \\cdots + m_1 - m_j)}{(m_{k+1} + \\cdots + m_1+1)(m_{k+1} + \\cdots + m_1)^2} \\end{align*} 又 \\begin{align*} x_p x_q f_{\\mv} (\\xv) & = \\frac{\\Gamma(m_{k+1} + \\cdots + m_1)}{\\Gamma(m_{k+1}) \\cdots \\Gamma(m_1)} x_p x_q \\prod_{i=1}^{k+1} x_i^{m_i - 1} \\\\ & = \\frac{\\Gamma(m_{k+1} + \\cdots + m_1)}{\\Gamma(m_{k+1} + \\cdots + m_p + 1 + \\cdots + m_q + 1 + \\cdots + m_1)} \\cdot \\frac{\\Gamma(m_p + 1)}{\\Gamma(m_p)} \\cdot \\frac{\\Gamma(m_q + 1)}{\\Gamma(m_q)} \\\\ & \\qquad \\qquad \\cdot \\frac{\\Gamma(m_{k+1} + \\cdots + m_p + 1 + \\cdots + m_q + 1 + \\cdots + m_1)}{\\Gamma(m_{k+1}) \\cdots \\Gamma(m_p + 1) \\cdots \\Gamma(m_q + 1) \\cdots \\Gamma(m_1)} x_p x_q \\prod_{i=1}^{k+1} x_i^{m_i - 1} \\end{align*} 于是 \\begin{align*} \\Ebb[x_p x_q] & = \\frac{\\Gamma(m_{k+1} + \\cdots + m_1)}{\\Gamma(m_{k+1} + \\cdots + m_p + 1 + \\cdots + m_q + 1 + \\cdots + m_1)} \\cdot \\frac{\\Gamma(m_p + 1)}{\\Gamma(m_p)} \\cdot \\frac{\\Gamma(m_q + 1)}{\\Gamma(m_q)} \\\\ & = \\frac{m_p m_q}{(m_{k+1} + \\cdots + m_1 + 1)(m_{k+1} + \\cdots + m_1)} \\end{align*} 故协方差为 \\begin{align*} \\cov(x_p, x_q) & = \\Ebb[x_p x_q] - \\Ebb[x_p] \\Ebb[x_q] \\\\ & = \\frac{m_p m_q}{(m_{k+1} + \\cdots + m_1 + 1)(m_{k+1} + \\cdots + m_1)} - \\frac{m_p}{m_{k+1} + \\cdots + m_1} \\cdot \\frac{m_q}{m_{k+1} + \\cdots + m_1} \\\\ & = \\frac{-m_p m_q}{(m_{k+1} + \\cdots + m_1+1)(m_{k+1} + \\cdots + m_1)^2} \\end{align*} 　　由式(\\ref{eq: E2})知 \\begin{align*} \\pr(x_1 = t) & = t^{m_1 - 1} \\frac{\\Gamma(m_{k+1}) \\Gamma(m_k) \\cdots \\Gamma(m_2)}{\\Gamma(m_{k+1} + m_k + \\cdots + m_2)} (1-t)^{m_{k+1} + m_k + \\cdots + m_2 - 1} \\\\ & = \\frac{\\Gamma(m_{k+1}) \\Gamma(m_k) \\cdots \\Gamma(m_1)}{\\Gamma(m_1) \\Gamma(m_{k+1} + m_k + \\cdots + m_1 - m_1)} t^{m_1 - 1} (1-t)^{m_{k+1} + m_k + \\cdots + m_1 - m_1 - 1} \\end{align*} 由对称性可知 \\begin{align*} \\pr(x_i = t) = \\frac{\\Gamma(m_{k+1}) \\Gamma(m_k) \\cdots \\Gamma(m_1)}{\\Gamma(m_i) \\Gamma(m_{k+1} + m_k + \\cdots + m_1 - m_i)} t^{m_i - 1} (1-t)^{m_{k+1} + m_k + \\cdots + m_1 - m_i - 1} \\end{align*} 这意味着Dirichlet分布的变量x_i的边际分布是参数为m_i、m_{k+1} + m_k + \\cdots + m_1 - m_i的Beta分布。 Copyright © Avanti 2020 all right reserved，powered by Gitbook文件最后修改时间： 2021-06-19 10:00:22 "},"posts/probability/conjugate-prior.html":{"url":"posts/probability/conjugate-prior.html","title":"共轭先验","keywords":"","body":"　　Bayes公式描述了后验与先验和似然的关系： \\begin{align*} \\pr(y|x) = \\frac{\\pr(x|y) \\pr(y)}{\\pr(x)} \\varpropto \\pr(x|y) \\pr(y) \\end{align*} 通常后验与先验不属于同一个分布族，但也存在一些特例，当它们同属一个分布族时，此先验称为似然的共轭先验，常见的有Gamma-Poisson共轭、Beta-Binomial共轭、Multinomial-Dirichlet共轭。 Gamma-Poisson共轭 　　对\\Gamma函数的积分变量做线性变换z = \\alpha y，于是有 \\begin{align*} \\Gamma(n) = \\int_0^\\infty e^{-z} z^{n-1} \\diff z = \\int_0^\\infty e^{-\\alpha y} \\alpha^n y^{n-1} \\diff y \\Longrightarrow 1 = \\int_0^\\infty \\frac{\\alpha^n y^{n-1} e^{- \\alpha y}}{\\Gamma(n)} \\diff y \\end{align*} 设y服从参数为n、\\alpha的Gamma分布： \\begin{align*} \\pr(y) = \\frac{\\alpha^n y^{n-1} e^{- \\alpha y}}{\\Gamma(n)} \\end{align*} 在给定y的条件下，设x服从参数为y的Poisson分布： \\begin{align*} \\pr(x = k|y) = \\frac{y^k e^{-y}}{k!} \\end{align*} 由全概率公式有 \\begin{align*} \\pr(x=k) & = \\int_0^\\infty \\pr(y) \\pr(x=k|y) \\diff y = \\int_0^\\infty \\frac{\\alpha^n y^{n-1} e^{- \\alpha y}}{\\Gamma(n)} \\frac{y^k e^{-y}}{k!} \\diff y \\\\ & = \\frac{\\alpha^n}{\\Gamma(n) k!} \\frac{\\Gamma(n+k)}{(\\alpha+1)^{n+k}} \\int_0^\\infty \\frac{(\\alpha+1)^{n+k} y^{n + k -1} e^{- (\\alpha+1) y}}{\\Gamma(n+k)} \\diff y \\\\ & = \\frac{\\alpha^n}{\\Gamma(n) k!} \\frac{\\Gamma(n+k)}{(\\alpha+1)^{n+k}} \\end{align*} 于是 \\begin{align*} \\pr(y|x = k) & = \\frac{\\pr(y) \\pr(x = k|y)}{\\pr(x = k)} = \\frac{\\alpha^n}{\\Gamma(n) k!} y^{n + k -1} e^{- (\\alpha+1) y} / \\frac{\\alpha^n}{\\Gamma(n) k!} \\frac{\\Gamma(n+k)}{(\\alpha+1)^{n+k}} \\\\ & = \\frac{(\\alpha+1)^{n+k} y^{n + k -1} e^{- (\\alpha+1) y}}{\\Gamma(n+k)} \\end{align*} 即后验服从参数为n + k、\\alpha + 1的Gamma分布。 Beta-Binomial共轭 　　设y服从参数为\\alpha、\\beta的Beta分布： \\begin{align*} \\pr(y) = \\frac{y^{\\alpha - 1} (1 - y)^{\\beta - 1}}{B(\\alpha, \\beta)} = \\frac{\\Gamma(\\alpha+\\beta)}{\\Gamma(\\alpha) \\Gamma(\\beta)} y^{\\alpha - 1} (1 - y)^{\\beta - 1} \\end{align*} 在给定y的条件下，设x服从参数为y的Binomial分布： \\begin{align*} \\pr(x=k|y) = \\binom{n}{k} y^k (1-y)^{n-k} \\end{align*} 由全概率公式有 \\begin{align*} \\pr(x=k) & = \\int_0^1 \\pr(y) \\pr(x=k|y) \\diff y = \\int_0^1 \\frac{\\Gamma(\\alpha+\\beta)}{\\Gamma(\\alpha) \\Gamma(\\beta)} \\binom{n}{k} y^{\\alpha+k-1} (1-y)^{\\beta+n-k-1} \\diff y \\\\ & = \\frac{\\Gamma(\\alpha+\\beta)}{\\Gamma(\\alpha) \\Gamma(\\beta)} \\binom{n}{k} \\frac{\\Gamma(\\alpha+k) \\Gamma(\\beta+n-k)}{\\Gamma(\\alpha+\\beta+n)} \\int_0^1 \\frac{\\Gamma(\\alpha+\\beta+n)}{\\Gamma(\\alpha+k) \\Gamma(\\beta+n-k)} y^{\\alpha+k-1} (1-y)^{\\beta+n-k-1} \\diff y \\\\ & = \\frac{\\Gamma(\\alpha+\\beta)}{\\Gamma(\\alpha) \\Gamma(\\beta)} \\binom{n}{k} \\frac{\\Gamma(\\alpha+k) \\Gamma(\\beta+n-k)}{\\Gamma(\\alpha+\\beta+n)} \\end{align*} 于是 \\begin{align*} \\pr(y|x = k) & = \\frac{\\Gamma(\\alpha+\\beta)}{\\Gamma(\\alpha) \\Gamma(\\beta)} \\binom{n}{k} y^{\\alpha+k-1} (1-y)^{\\beta+n-k-1} / \\frac{\\Gamma(\\alpha+\\beta)}{\\Gamma(\\alpha) \\Gamma(\\beta)} \\binom{n}{k} \\frac{\\Gamma(\\alpha+k) \\Gamma(\\beta+n-k)}{\\Gamma(\\alpha+\\beta+n)} \\\\ & = \\frac{\\Gamma(\\alpha+\\beta+n)}{\\Gamma(\\alpha+k) \\Gamma(\\beta+n-k)} y^{\\alpha+k-1} (1-y)^{\\beta+n-k-1} \\end{align*} 即后验服从参数为\\alpha + k、\\beta + n - k的Beta分布。 Multinomial-Dirichlet共轭 　　Dirichlet分布是Beta分布的多元扩展，Multinomial分布是Binomial分布的多元扩展，不难猜测Dirichlet分布是Multinomial分布的共轭先验。设\\yv = [y_1; \\ldots; y_{k+1}]服从参数为\\alphav = [\\alpha_1; \\ldots; \\alpha_{k+1}]的Dirichlet分布，即 \\begin{align*} \\pr(\\yv) = \\frac{\\Gamma(\\alpha_{k+1} + \\cdots + \\alpha_1)}{\\Gamma(\\alpha_{k+1}) \\cdots \\Gamma(\\alpha_1)} \\prod_{i=1}^{k+1} y_i^{\\alpha_i - 1} \\end{align*} 在给定\\yv的条件下，设\\xv服从参数为\\yv的Multinomial分布： \\begin{align*} \\pr(\\xv=\\nv | \\yv) = \\frac{\\Gamma(n_{k+1} + \\cdots + n_1)}{\\Gamma(n_{k+1}) \\cdots \\Gamma(n_1)} \\prod_{i=1}^{k+1} y_i^{n_i} \\end{align*} 由全概率公式有 \\begin{align*} \\pr(\\xv = \\nv) & = \\int \\cdots \\int \\pr(\\yv) \\pr(\\xv = \\nv|\\yv) \\diff \\yv \\\\ & = \\frac{\\Gamma(\\alpha_{k+1} + \\cdots + \\alpha_1)}{\\Gamma(\\alpha_{k+1}) \\cdots \\Gamma(\\alpha_1)} \\frac{\\Gamma(n_{k+1} + \\cdots + n_1)}{\\Gamma(n_{k+1}) \\cdots \\Gamma(n_1)} \\int \\cdots \\int \\prod_{i=1}^{k+1} y_i^{\\alpha_i + n_i - 1} \\diff y_1 \\cdots \\diff y_k \\\\ & = \\frac{\\Gamma(\\alpha_{k+1} + \\cdots + \\alpha_1)}{\\Gamma(\\alpha_{k+1}) \\cdots \\Gamma(\\alpha_1)} \\frac{\\Gamma(n_{k+1} + \\cdots + n_1)}{\\Gamma(n_{k+1}) \\cdots \\Gamma(n_1)} \\frac{\\Gamma(\\alpha_{k+1}+n_{k+1}) \\cdots \\Gamma(\\alpha_1+n_1)}{\\Gamma(\\alpha_{k+1}+n_{k+1} + \\cdots + \\alpha_1+n_1)} \\end{align*} 于是 \\begin{align*} \\pr(\\yv|\\xv = \\nv) & = \\prod_{i=1}^{k+1} y_i^{\\alpha_i + n_i - 1} / \\frac{\\Gamma(\\alpha_{k+1}+n_{k+1}) \\cdots \\Gamma(\\alpha_1+n_1)}{\\Gamma(\\alpha_{k+1}+n_{k+1} + \\cdots + \\alpha_1+n_1)} \\\\ & = \\frac{\\Gamma(\\alpha_{k+1} + n_{k+1} + \\cdots + \\alpha_1 + n_1)}{\\Gamma(\\alpha_{k+1} + n_{k+1}) \\cdots \\Gamma(\\alpha_1 + n_1)} \\prod_{i=1}^{k+1} y_i^{\\alpha_i + n_i - 1} \\end{align*} 即后验服从参数为\\alphav + \\nv的Dirichlet分布。 Copyright © Avanti 2020 all right reserved，powered by Gitbook文件最后修改时间： 2021-06-20 00:22:30 "},"posts/optimization/analysis/extreme-point.html":{"url":"posts/optimization/analysis/extreme-point.html","title":"极点的等价定义","keywords":"","body":"　　设凸多面体\\Pcal = \\{ \\xv \\mid \\Av \\xv \\leq \\bv \\} \\subseteq \\Rbb^n，则下面四个条件均可作为极点\\vv的定义： 存在支撑超平面\\Hcal = \\{ \\xv \\mid \\wv^\\top \\xv = \\lambda \\}使得对任意\\xv \\in \\Pcal有\\wv^\\top \\xv \\leq \\lambda且\\Pcal \\cap \\Hcal = \\{ \\vv \\}； \\vv无法表示成\\Pcal \\setminus \\{ \\vv \\}中元素的凸组合； 不存在非零向量\\dv使得\\vv \\pm \\dv \\in \\Pcal； 存在n个约束\\av_i^\\top \\xv \\leq b_i在\\vv处是紧的，即\\av_i^\\top \\vv = b_i，且\\av_1, \\ldots, \\av_n线性无关。 　　证明： 1 \\Rightarrow 2：若\\vv = \\sum_i \\alpha_i \\vv_i，其中\\sum_i \\alpha_i = 1且\\alpha_i \\ge 0，则 \\begin{align*} \\lambda = \\wv^\\top \\vv = \\sum_i \\alpha_i \\wv^\\top \\vv_i \\leq \\sum_i \\alpha_i \\lambda = \\lambda \\end{align*} 故对所有的\\vv_i都有\\wv^\\top \\vv_i = \\lambda，这和\\Pcal、\\Hcal有唯一交集\\vv矛盾。 2 \\Rightarrow 3：若\\vv \\pm \\dv \\in \\Pcal，则\\vv = \\frac{1}{2} (\\vv + \\dv) + \\frac{1}{2} (\\vv - \\dv)是一个凸组合表示，矛盾。 3 \\Rightarrow 4：设所有紧约束的法向量集合为\\Tcal = \\{ \\av_i \\mid \\av_i^\\top \\vv = b_i \\}，若\\dim (\\spn (\\Tcal)) ，即\\Tcal只能张成\\Rbb^n的真子空间，则存在非零向量\\dv与\\spn(\\Tcal)正交，于是 \\begin{align*} & \\av_i^\\top (\\vv + \\epsilon \\dv) = \\av_i^\\top \\vv = b_i, ~ \\forall \\av_i \\in \\Tcal \\\\ & \\av_i^\\top \\vv \\epsilon > 0使得对任意i有\\av_i^\\top (\\vv \\pm \\epsilon \\dv) \\le b_i，故\\vv \\pm \\epsilon \\dv \\in \\Pcal，矛盾。 4 \\Rightarrow 1：构造超平面 \\begin{align*} \\Hcal = \\left\\{ \\xv \\mid \\sum_{i \\in [n]} \\av_i^\\top \\xv = \\sum_{i \\in [n]} b_i \\right\\} \\end{align*} 显然对任意\\xv \\in \\Pcal有\\sum_{i \\in [n]} \\av_i^\\top \\xv \\leq \\sum_{i \\in [n]} b_i。若想取等号，则必须有[\\av_1, \\ldots, \\av_n]^\\top \\xv = [b_1; \\ldots; b_n]，由\\av_1, \\ldots, \\av_n线性无关知该线性方程组有唯一解，即\\vv。 　　 Copyright © Avanti 2020 all right reserved，powered by Gitbook文件最后修改时间： 2021-06-19 10:20:29 "},"posts/optimization/dual/LP-dual-interpretation.html":{"url":"posts/optimization/dual/LP-dual-interpretation.html","title":"线性规划下的解释","keywords":"","body":"　　有一位农民种植水稻、麦子和玉米，这三种作物的单位收益分别是s_1、s_2、s_3，每单位的水稻、麦子和玉米需要f_1、f_2、f_3单位的肥料和p_1、p_2、p_3单位的农药，假设该农民总共有f单位的肥料和p单位的农药，那么每种作物各种植多少才能收益最大？ 　　上述问题可以形式化成一个线性规划，设三种作物种植的单位分别是x_1、x_2、x_3，那么要求解的就是 \\begin{align*} \\min_{x_1, x_2, x_3} & \\quad - s_1 x_1 - s_2 x_2 - s_3 x_3 \\\\ \\st & \\quad f_1 x_1 + f_2 x_2 + f_3 x_3 \\le f \\\\ & \\quad p_1 x_1 + p_2 x_2 + p_3 x_3 \\le p \\\\ & \\quad x_1 \\ge 0, ~ x_2 \\ge 0, ~ x_3 \\ge 0 \\end{align*} 　　Lagrange对偶函数为 \\begin{align*} L & = - s_1 x_1 - s_2 x_2 - s_3 x_3 + y_1 (f_1 x_1 + f_2 x_2 + f_3 x_3 - f) \\\\ & \\qquad \\qquad + y_2 (p_1 x_1 + p_2 x_2 + p_3 x_3 - p) - z_1 x_1 - z_2 x_2 - z_3 x_3 \\end{align*} 令L关于x_1、x_2、x_3的偏导数为零可得 \\begin{align*} \\frac{\\partial L}{\\partial x_1} & = - s_1 + y_1 f_1 + y_2 p_1 - z_1 = 0 \\Longrightarrow y_1 f_1 + y_2 p_1 = s_1 + z_1 \\ge s_1 \\\\ \\frac{\\partial L}{\\partial x_2} & = - s_2 + y_1 f_2 + y_2 p_2 - z_2 = 0 \\Longrightarrow y_1 f_2 + y_2 p_2 = s_2 + z_2 \\ge s_2 \\\\ \\frac{\\partial L}{\\partial x_3} & = - s_3 + y_1 f_3 + y_2 p_3 - z_3 = 0 \\Longrightarrow y_1 f_3 + y_2 p_3 = s_3 + z_3 \\ge s_3 \\end{align*} 故对偶问题为 \\begin{align*} \\max_{y_1, y_2} & \\quad - y_1 f - y_2 p \\\\ \\st & \\quad y_1 f_1 + y_2 p_1 \\ge s_1 \\\\ & \\quad y_1 f_2 + y_2 p_2 \\ge s_2 \\\\ & \\quad y_1 f_3 + y_2 p_3 \\ge s_3 \\\\ & \\quad y_1 \\ge 0, ~ y_2 \\ge 0 \\end{align*} 　　现在有一位商人，想从农民的手上收购肥料和农药，他开给农民的肥料和农药的单价分别是y_1、y_2，那么y_1 f + y_2 p就是商人收购全部f单位肥料和p单位农药的总开销，约束y_1 f_i + y_2 p_i \\ge s_i是指相对于农民自己种第i种作物，不如直接卖肥料和农药更划算。所以对偶问题描述的是，对商人来说，肥料和农药的单价各为多少，才能使得农民愿意卖且自己的开销最小。 　　根据弱对偶有- s_1 x_1 - s_2 x_2 - s_3 x_3 \\ge - y_1 f - y_2 p，即 \\begin{align*} s_1 x_1 + s_2 x_2 + s_3 x_3 \\le y_1 f + y_2 p \\end{align*} 所以弱对偶说的是在农民不贱卖资源的情况下，再精明的商人也无法让自己的最小开销低于农民的最大收益，最精明的商人是使得两者相等，即强对偶成立。 Copyright © Avanti 2020 all right reserved，powered by Gitbook文件最后修改时间： 2021-06-19 10:20:29 "},"posts/optimization/dual/MCFC.html":{"url":"posts/optimization/dual/MCFC.html","title":"匹配、覆盖、流、割","keywords":"","body":"　　设二部图\\Gcal = (\\Vcal, \\Ecal)，其中\\Vcal = \\Vcal_1 \\uplus \\Vcal_2，\\Ecal \\subseteq \\Vcal_1 \\times \\Vcal_2，\\delta(v)为与点v相连的边的集合。若\\Mcal \\subseteq \\Ecal且其中任意两条边没有公共顶点，即不存在长度\\ge 2的路径，则称\\Mcal为匹配(matching)，其可表示为向量\\xv \\in \\Zbb_+^{|\\Ecal|}满足对任意v \\in \\Vcal有\\sum_{e \\in \\delta(v)} x_e \\le 1。若\\Ccal \\subseteq \\Vcal使得\\Gcal的每条边都至少有一个顶点属于\\Ccal，则称\\Ccal为覆盖(cover)，其可表示为向量\\zv \\in \\Zbb_+^{|\\Vcal|}使得对任意(u,v) \\in \\Ecal有z_u + z_v \\ge 1。 　　设\\Av \\in \\{ 0,1 \\}^{|\\Vcal| \\times |\\Ecal|}是二部图\\Gcal对应的关联矩阵，即a_{v,e} = 1_{e \\in \\delta(v)}，则 \\begin{align*} \\forall v \\in \\Vcal, \\sum_{e \\in \\delta(v)} x_e \\le 1 & \\Longleftrightarrow \\Av \\xv \\le \\ev \\\\ \\forall (u,v) \\in \\Ecal, ~ z_u + z_v \\ge 1 & \\Longleftrightarrow \\Av^\\top \\zv \\ge \\ev \\end{align*} 最大匹配 　　所有匹配中，势最大的称为最大匹配，求解最大匹配可形式化成 \\begin{align} \\label{eq: max-matching} \\max_{\\xv} \\{ \\ev^\\top \\xv : \\xv \\in \\Zbb_+^{|\\Ecal|}, ~ \\Av \\xv \\le \\ev \\} \\end{align} 由于第一个约束的存在，这是一个整数规划，难以直接求解，将可行域放松成连续域可得线性规划 \\begin{align} \\label{eq: relax-max-matching} \\max_{\\xv} \\{ \\ev^\\top \\xv : \\xv \\ge \\zerov, ~ \\Av \\xv \\le \\ev \\} \\end{align} 注意\\{ \\xv \\ge \\zerov, ~ \\Av \\xv \\le \\ev \\} \\Longleftrightarrow [\\Av; -\\Iv] \\xv \\le [\\ev; \\zerov]，由于二部图的关联矩阵必然是全幺模矩阵，故[\\Av; -\\Iv]也是全幺模矩阵，又[\\ev; \\zerov]是整数向量，故凸多面体\\{ \\xv \\ge \\zerov, ~ \\Av \\xv \\le \\ev \\}的极点是整数向量。由于线性规划必然在极点处取最优，因此式(\\ref{eq: relax-max-matching})的最优解就是式(\\ref{eq: max-matching})的最大匹配。 　　上述将离散整数约束替换为连续实数约束的操作，其实是将可行域由匹配集合扩大成其凸包。 定理1：记匹配\\Mcal对应的表示向量为\\xv^{(\\Mcal)}，\\Pcal (\\Gcal) \\triangleq \\conv \\{ \\xv^{(\\Mcal_1)}, \\xv^{(\\Mcal_2)}, \\ldots \\}，\\Qcal (\\Gcal)定义为： \\begin{align*} \\Qcal (\\Gcal) = \\{ \\xv \\mid \\xv \\ge \\zerov, ~ \\Av \\xv \\le \\ev \\} = \\left\\{ \\xv \\in \\Rbb_+^{|\\Vcal|} \\mid \\forall v \\in \\Vcal, \\sum_{e \\in \\delta(v)} x_e \\le 1 \\right\\} \\end{align*} 那么\\Pcal (\\Gcal) = \\Qcal (\\Gcal)。 证明：正向比较简单，对任意\\xv = \\sum_{i \\in [n]} \\alpha^{(\\Mcal_i)} \\xv^{(\\Mcal_i)} \\in \\Pcal(\\Gcal)，易知 \\begin{align*} \\sum_{e \\in \\delta(v)} x_e & = \\sum_{e \\in \\delta(v)} \\sum_{i \\in [n]} \\alpha^{(\\Mcal_i)} x^{(\\Mcal_i)}_e = \\sum_{i \\in [n]} \\alpha^{(\\Mcal_i)} \\underbrace{\\sum_{e \\in \\delta(v)} x^{(\\Mcal_i)}_e}_{\\le 1} \\le \\sum_{i \\in [n]} \\alpha^{(\\Mcal_i)} = 1 \\end{align*} 其中不等号是因为对任意匹配，点v相连的边中最多只有一条属于该匹配。 　　反向较为麻烦，对任意\\xv \\in \\Qcal (\\Gcal)，设\\supp(\\xv) = \\{ e \\in \\Ecal \\mid x_e > 0 \\}。下面对|\\supp(\\xv)|进行归纳，若|\\supp(\\xv)| = 0，则\\xv = \\zerov就是零匹配；若|\\supp(\\xv)| = 1，显然\\xv可以表示成零匹配和单边匹配的凸组合。若|\\supp(\\xv)| \\ge 2，分两种情况讨论： \\supp(\\xv)不是匹配，则\\supp(\\xv)包含长度\\ge 2的路径，不妨就设为v_1 \\xrightarrow{e_1} v_2 \\xrightarrow{e_2} v_3，由于x_{e_1}, x_{e_2} > 0，故x_{e_1}, x_{e_2} ，否则\\sum_{e \\in \\delta(v_2)} x_e = x_{e_1} + x_{e_2} > 1。引入 \\begin{align*} d_e = \\begin{cases} 1 & e = e_1 \\\\ -1 & e = e_2 \\\\ 0 & \\ow \\end{cases} \\end{align*} 现考虑\\xv + \\epsilon \\dv，当\\epsilon增大时，x_{e_1} + \\epsilon d_{e_1}增大，x_{e_2} + \\epsilon d_{e_2}减小，当x_{e_2} + \\epsilon d_{e_2}变为零时，记此时的\\epsilon为\\epsilon_1，定义\\xv_1 \\triangleq \\xv + \\epsilon_1 \\dv；同理对于\\xv - \\epsilon \\dv，当\\epsilon增大时，x_{e_1} - \\epsilon \\dv_{e_1}减小，x_{e_2} - \\epsilon \\dv_{e_2}增大，当x_{e_1} - \\epsilon \\dv_{e_1}变为零时，记此时的\\epsilon为\\epsilon_2，定义\\xv_2 \\triangleq \\xv - \\epsilon_2 \\dv，那么 \\begin{align*} \\epsilon_2 \\epsilon_1 \\dv = \\epsilon_2 \\xv_1 - \\epsilon_2 \\xv = \\epsilon_1 \\xv - \\epsilon_1 \\xv_2 \\Longrightarrow \\xv = \\frac{\\epsilon_2}{\\epsilon_1 + \\epsilon_2} \\xv_1 + \\frac{\\epsilon_1}{\\epsilon_1 + \\epsilon_2} \\xv_2 = \\conv\\{ \\xv_1, \\xv_2 \\} \\end{align*} 注意|\\supp(\\xv_1)| = |\\supp(\\xv_2)| = |\\supp(\\xv)| - 1，由归纳假设知\\xv_1,\\xv_2 \\in \\Pcal(\\Gcal)，于是\\xv \\in \\Pcal(\\Gcal)。 \\supp(\\xv)是匹配，不妨设\\supp(\\xv) = \\{ e_1, e_2, e_3, \\ldots, e_n \\}且x_{e_1} \\le x_{e_2} \\le x_{e_3} \\le \\cdots \\le x_{e_n}，定义 \\begin{align*} \\Mcal_i \\triangleq \\{ e_i, e_{i+1}, \\ldots, e_n \\}, \\quad \\xv^{(\\Mcal_i)} = [\\underbrace{0, \\ldots, 0}_{1:i-1}, \\underbrace{1, 1, \\ldots, 1}_{i:n}, \\underbrace{0, \\ldots, 0}_{n+1:|\\Ecal|}], \\quad i \\in [n] \\end{align*} 则 \\begin{align*} \\xv & = \\begin{bmatrix} x_{e_1} \\\\ x_{e_2} \\\\ x_{e_3} \\\\ \\vdots \\\\ x_{e_n} \\\\ \\zerov \\end{bmatrix} = \\begin{bmatrix} x_{e_1} \\\\ x_{e_1} \\\\ x_{e_1} \\\\ \\vdots \\\\ x_{e_1} \\\\ \\zerov \\end{bmatrix} + \\begin{bmatrix} 0 \\\\ x_{e_2} - x_{e_1} \\\\ x_{e_2} - x_{e_1} \\\\ \\vdots \\\\ x_{e_2} - x_{e_1} \\\\ \\zerov \\end{bmatrix} + \\begin{bmatrix} 0 \\\\ 0 \\\\ x_{e_3} - x_{e_2} \\\\ \\vdots \\\\ x_{e_3} - x_{e_2} \\\\ \\zerov \\end{bmatrix} + \\cdots \\\\ & = x_{e_1} \\xv^{(\\Mcal_1)} + (x_{e_2} - x_{e_1}) \\xv^{(\\Mcal_2)} + (x_{e_3} - x_{e_2}) \\xv^{(\\Mcal_3)} \\\\ & \\qquad + \\cdots + (x_{e_n} - x_{e_{n-1}}) \\xv^{(\\Mcal_n)} + (1 - x_{e_n}) \\zerov \\in \\Pcal (\\Gcal) \\end{align*} 　　由定义\\Pcal (\\Gcal) = \\conv \\{ \\xv^{(\\Mcal_1)}, \\xv^{(\\Mcal_2)}, \\ldots \\}知\\Pcal (\\Gcal)的任意极点都是\\Gcal的匹配，反过来结论也成立。 定理2：\\Gcal的任意匹配都是\\Pcal的极点。 证明：对任意匹配\\Mcal和非零向量\\dv，不妨设d_e \\neq 0，注意x^{(\\Mcal)}_e \\in \\{0, 1\\}，因此x^{(\\Mcal)}_e \\pm \\epsilon d_e总有一个不属于[0,1]，即\\xv^{(\\Mcal)} \\pm \\epsilon \\dv总有一个不属于\\Pcal，故\\xv^{(\\Mcal)}是\\Pcal的极点。 完美匹配 　　若匹配\\Mcal^\\star使得在子图(\\Vcal, \\Mcal^\\star)中，所有点都有且仅有一条相连的边，则称为完美匹配(perfect matching)。完美匹配可表示为向量\\xv \\in \\Zbb_+^{|\\Ecal|}满足对任意v \\in \\Vcal有\\sum_{e \\in \\delta(v)} x_e = 1，显然完美匹配是匹配的真子集。 定理3：设\\Pcal^\\star (\\Gcal)为\\Gcal的所有完美匹配构成的凸包，\\Qcal^\\star (\\Gcal)定义为： \\begin{align*} \\Qcal^\\star (\\Gcal) = \\{ \\xv \\mid \\xv \\ge \\zerov, ~ \\class{blue}{\\Av \\xv = \\ev} \\} = \\left\\{ \\xv \\in \\Rbb_+^{|\\Vcal|} \\mid \\forall v \\in \\Vcal, \\class{blue}{\\sum_{e \\in \\delta(v)} x_e = 1} \\right\\} \\end{align*} 则\\Pcal^\\star (\\Gcal) = \\Qcal^\\star (\\Gcal)。 证明：一方面，对任意\\xv = \\sum_{i \\in [n]} \\alpha^{(\\Mcal_i^\\star)} \\xv^{(\\Mcal_i^\\star)} \\in \\Pcal^\\star(\\Gcal)，易知 \\begin{align*} \\sum_{e \\in \\delta(v)} x_e & = \\sum_{e \\in \\delta(v)} \\sum_{i \\in [n]} \\alpha^{(\\Mcal_i^\\star)} x^{(\\Mcal_i^\\star)}_e = \\sum_{i \\in [n]} \\alpha^{(\\Mcal_i^\\star)} \\sum_{e \\in \\delta(v)} x_e^{(\\Mcal_i^\\star)} = \\sum_{i \\in [n]} \\alpha^{(\\Mcal_i^\\star)} = 1 \\Longrightarrow \\xv \\in \\Qcal^\\star (\\Gcal) \\end{align*} 　　另一方面，对任意\\xv \\in \\Qcal^\\star(\\Gcal) \\subseteq \\Qcal(\\Gcal) = \\Pcal(\\Gcal)，设\\xv = \\sum_{i \\in [n]} \\alpha^{(\\Mcal_i)} \\xv^{(\\Mcal_i)}。用反证法，若其凸组合表示中存在不完美匹配\\Mcal_j，设v不是\\Mcal_j中边的顶点，则 \\begin{align*} \\sum_{e \\in \\delta(v)} x_e = \\sum_{e \\in \\delta(v)} \\sum_{i \\in [n] \\setminus \\{j\\}} \\alpha^{(\\Mcal_i)} x_e^{(\\Mcal_i)} = \\sum_{i \\in [n] \\setminus \\{j\\}} \\alpha^{(\\Mcal_i)} \\sum_{e \\in \\delta(v)} x_e^{(\\Mcal_i)} \\le \\sum_{i \\in [n] \\setminus \\{j\\}} \\alpha^{(\\Mcal_i)} \\Qcal^\\star (\\Gcal)的定义矛盾，故\\xv的凸组合表示中不存在不完美匹配，即\\xv \\in \\Pcal^\\star (\\Gcal)。 定理4：\\Gcal的任意完美匹配都是\\Pcal^\\star的极点。 证明：完美匹配也是匹配，因此是\\Pcal的极点，故无法由\\Pcal中其它点的凸组合表示，又\\Pcal^\\star \\subseteq \\Pcal，因此也无法由\\Pcal^\\star中其它点的凸组合表示，从而也是\\Pcal^\\star的极点 　　对于完全二部图\\Kcal_{n,n}有|\\Ecal| = n^2，对任意\\xv \\in \\Qcal^\\star(\\Kcal_{n,n})有 \\begin{align*} \\xv \\in \\Rbb_+^{n^2}, ~ \\forall v \\in \\Vcal, \\sum_{e \\in \\delta(v)} x_e = 1 \\end{align*} 又每个点恰有n条相连的边，因此\\xv也可以写成一个n \\times n的双随机矩阵(所有行和、列和均为1)。另一方面，对于完美匹配\\Mcal，每个点有且仅有一条相连的边，其对应的\\xv^{(\\Mcal)}可以写成置换矩阵(每行、每列有且仅有一个1，其余为零)，由定理4知双随机矩阵集合的极点是置换矩阵，这就是Birkhoff-von Neumann定理。 König定理 　　前文已述最大匹配问题可放松成线性规划 \\begin{align*} \\max_{\\xv} \\{ \\ev^\\top \\xv : \\xv \\ge \\zerov, ~ \\Av \\xv \\le \\ev \\} \\end{align*} 引入Lagrange对偶函数\\Lcal(\\xv, \\yv, \\zv) = \\ev^\\top \\xv + \\yv^\\top \\xv - \\zv^\\top (\\Av \\xv - \\ev)，易知 \\begin{align*} \\frac{\\partial \\Lcal}{\\partial \\xv} = \\ev + \\yv - \\Av^\\top \\zv = \\zerov \\Longrightarrow \\Av^\\top \\zv - \\ev = \\yv \\geq \\zerov \\end{align*} 故对偶问题为 \\begin{align} \\label{eq: relax-min-vertex-cover} \\min_{\\zv} \\{ \\ev^\\top \\zv : \\zv \\ge \\zerov, ~ \\Av^\\top \\zv \\ge \\ev \\} \\end{align} 显然这是将最小点覆盖问题 \\begin{align} \\label{eq: min-vertex-cover} \\min_{\\zv} \\{ \\ev^\\top \\zv : \\zv \\in \\Zbb_+^{|\\Vcal|}, ~ \\Av^\\top \\zv \\ge \\ev \\} \\end{align} 的离散可行域放松成连续域得到的线性规划。同理由\\{ \\zv \\ge \\zerov, ~ \\Av^\\top \\zv \\ge \\ev \\} \\Longleftrightarrow [-\\Av^\\top; -\\Iv] \\zv \\le [-\\ev; \\zerov]以及\\Av是全幺模矩阵知凸多面体\\{ \\zv \\mid \\zv \\ge \\zerov, ~ \\Av^\\top \\zv \\ge \\ev \\}的极点是整数向量。由于线性规划必然在极点处取最优，因此式(\\ref{eq: relax-min-vertex-cover})的最优解就是式(\\ref{eq: min-vertex-cover})的最小点覆盖。 　　综上，最大匹配、最小点覆盖这两类整数规划问题，其最优解就是将整数约束放松后导出的线性规划的最优解，且这两类相应的线性规划互为对偶问题。 定理5：对于二部图\\Gcal = (\\Vcal, \\Ecal)，设最大匹配问题的最优值为\\maxm(\\Gcal)，最小点覆盖问题的最优值为\\minvc(\\Gcal)，则有\\maxm(\\Gcal) = \\minvc(\\Gcal)。 证明：\\minvc(\\Gcal) \\ge \\maxm(\\Gcal)是显然的，因为对最大匹配中的任意一条边，至少要覆盖其中一个顶点。 　　下面证明另一个方向，若\\Ecal = \\emptyset，则\\maxm(\\Gcal) = \\minvc(\\Gcal) = 0，故不妨设\\Ecal非空。对|\\Vcal|进行归纳，若|\\Vcal| = 2，易知\\maxm(\\Gcal) = \\minvc(\\Gcal) = 1。若|\\Vcal| > 2，设\\zv^\\star是最小点覆盖问题的最优解，由于存在点v使得z_v^\\star > 0，故根据互补松弛条件可得 \\begin{align*} z_v^\\star (\\Av_{v,:} \\xv^\\star - 1) = 0 \\Longrightarrow 1 = \\Av_{v,:} \\xv^\\star = \\sum_{e \\in \\delta(v)} x_e^\\star \\end{align*} 又原问题的最优解\\xv^\\star是最大匹配，故v出现在所有的最大匹配中，记\\Gcal'为\\Gcal删除点v及其相连边后得到的图，于是 \\begin{align*} \\maxm(\\Gcal') = \\maxm(\\Gcal) - 1 \\end{align*} 由归纳假设知\\maxm(\\Gcal') = \\minvc(\\Gcal')，于是 \\begin{align*} \\minvc(\\Gcal) & \\le \\minvc(\\Gcal') + 1 \\\\ & = \\maxm(\\Gcal') + 1 \\\\ & = \\maxm(\\Gcal) \\end{align*} 　　König定理还可进一步推广，设b-匹配对应的表示向量满足对任意v \\in \\Vcal有\\sum_{e \\in \\delta(v)} x_e \\le b_v；c-点覆盖对应的表示向量满足对任意e = (u,v) \\in \\Ecal有z_u + z_v \\ge c_e，易知有 \\begin{align*} \\max_{\\xv} \\{ \\cv^\\top \\xv : \\xv \\ge \\zerov, ~ \\Av \\xv \\le \\bv \\} = \\min_{\\zv} \\{ \\bv^\\top \\zv : \\zv \\ge \\zerov, ~ \\Av^\\top \\zv \\ge \\cv \\} \\end{align*} 即最大c-加权b-匹配等于最小b-加权c-点覆盖。 最大流与最小割 　　类似于最大匹配和最小点覆盖，最大流和最小割也是一组对偶问题。给定有向流网络\\Gcal = (\\Vcal, \\Ecal)、源点s、汇点t，设\\delta_{\\text{in}}(v)是以点v为终点的入边集合、\\delta_{\\text{out}}(v)是以点v为起点的出边集合，\\Av \\in \\{ 0, \\pm 1 \\}^{|\\Vcal| \\times |\\Ecal|}是\\Gcal对应的关联矩阵，即 \\begin{align*} a_{v,e} = \\begin{cases} 1 & e \\in \\delta_{\\text{in}} (v) \\\\ -1 & e \\in \\delta_{\\text{out}} (v) \\\\ 0 & \\ow \\end{cases} \\end{align*} \\Av'为\\Av去掉s、t对应行的子矩阵，注意有向流网络中源点s只有出边、汇点t只有入边，因此\\Av'其实也是\\Gcal删除s、t及其所有相连边后的有向图的关联矩阵，故\\Av'是全幺模矩阵。 　　最大流问题可形式化为线性规划： \\begin{align*} \\max_{\\xv} \\{ \\av^\\top \\xv : \\zerov \\le \\xv \\le \\cv, ~ \\Av' \\xv = \\zerov \\} \\end{align*} 其中\\av^\\top是\\Av中汇点t对应的行，\\zerov \\le \\xv \\le \\cv约束流的上下界，\\Av' \\xv = \\zerov约束非源点、汇点的流量要守恒。注意 \\begin{align*} \\{ \\xv \\mid \\zerov \\le \\xv \\le \\cv, ~ \\Av' \\xv = \\zerov \\} \\Longleftrightarrow [\\Av'; -\\Av'; \\Iv; -\\Iv] \\xv \\leq [\\zerov; \\zerov; \\cv; \\zerov] \\end{align*} 由\\Av'是全幺模矩阵知[\\Av'; -\\Av'; \\Iv; -\\Iv]也是全幺模矩阵，若流量上限\\cv是整数向量，则可行域\\{ \\zv \\mid \\zerov \\le \\xv \\le \\cv, ~ \\Av' \\xv = \\zerov \\}的极点也是整数向量，即最大流是整数流。 　　引入Lagrange对偶函数\\Lcal(\\xv, \\yv, \\zv, \\wv) = \\av^\\top \\xv + \\yv^\\top \\xv - \\zv^\\top (\\xv - \\cv) - \\wv'^\\top \\Av' \\xv，易知 \\begin{align*} \\frac{\\partial \\Lcal}{\\partial \\xv} = \\av + \\yv - \\zv - \\Av'^\\top \\wv' = \\zerov \\Longrightarrow \\Av'^\\top \\wv' + \\zv \\ge \\av \\end{align*} 故对偶问题为 \\begin{align*} \\min_{\\wv', \\zv} \\{ \\cv^\\top \\zv : \\zv \\ge \\zerov, ~ \\Av'^\\top \\wv' + \\zv \\ge \\av \\} \\end{align*} 注意 \\begin{align*} \\{ \\zv \\mid \\zv \\ge \\zerov, ~ \\Av'^\\top \\wv' + \\zv \\ge \\av \\} \\Longleftrightarrow [-\\Av'^\\top, -\\Iv; \\zerov, -\\Iv] [\\wv'; \\zv] \\leq [-\\av; \\zerov] \\end{align*} 由\\Av'是全幺模矩阵知[-\\Av'^\\top, -\\Iv; \\zerov, -\\Iv]也是全幺模矩阵，故对偶问题的最优解\\wv'^\\star、\\zv^\\star也是整数向量。 　　\\wv'^\\star的维度为|\\Vcal| - 2，与\\Av'的行对应，现添加w_s^\\star = 0、w_t^\\star = -1将其扩充为\\wv^\\star，与\\Av的行对应，于是\\Av^\\top \\wv^\\star + \\zv^\\star = \\Av'^\\top \\wv'^\\star - \\av + \\zv^\\star \\ge \\zerov。由于\\cv非负，故\\zv^\\star应尽量的小，从而\\zv^\\star = \\max \\{ \\zerov, - \\Av^\\top \\wv^\\star \\}，即对e = (u,v) \\in \\Ecal有z^\\star_e = \\max \\{ 0, w_u^\\star - w_v^\\star \\}。 　　定义\\Scal = \\{ v \\in \\Vcal \\mid w_v^\\star \\ge 0 \\}，\\overline{\\Scal} = \\Vcal \\setminus \\Scal，显然s \\in \\Scal、t \\in \\overline{\\Scal}，将边分为四类： \\delta(\\Scal) \\triangleq \\{ (u,v) \\in \\Ecal \\mid u \\in \\Scal, ~ v \\in \\Scal \\}为所有起点、终点均属于\\Scal的边的集合； \\delta(\\overline{\\Scal}) \\triangleq \\{ (u,v) \\in \\Ecal \\mid u \\in \\overline{\\Scal}, ~ v \\in \\overline{\\Scal} \\}为所有起点、终点均属于\\overline{\\Scal}的边的集合； \\delta_{\\text{out}}(\\Scal) \\triangleq \\{ (u,v) \\in \\Ecal \\mid u \\in \\Scal, ~ v \\in \\overline{\\Scal} \\}为所有起点属于\\Scal、终点属于\\overline{\\Scal}的边的集合； \\delta_{\\text{in}}(\\Scal) \\triangleq \\{ (u,v) \\in \\Ecal \\mid u \\in \\overline{\\Scal}, ~ v \\in \\Scal \\}为所有起点属于\\overline{\\Scal}、终点属于\\Scal的边的集合； 注意在将所有\\delta_{\\text{out}}(\\Scal)中的边删除后，s、t不再连通，因此\\delta_{\\text{out}}(\\Scal)称为割(cut)。 　　由于w_v^\\star都是整数，因此对任意e = (u,v) \\in \\delta_{\\text{out}}(\\Scal)有z_e^\\star \\ge w_u^\\star - w_v^\\star \\ge 1，因此 \\begin{align*} \\cv^\\top \\zv^\\star \\ge \\sum_{e \\in \\delta_{\\text{out}}(\\Scal)} c_e z_e^\\star \\ge \\sum_{e \\in \\delta_{\\text{out}}(\\Scal)} c_e \\ge \\sum_{e \\in \\delta_{\\text{out}}(\\Scal)} x_e^\\star \\ge \\sum_{e \\in \\delta_{\\text{in}}(t)} x_e^\\star = \\av^\\top \\xv^\\star \\ge \\cv^\\top \\zv^\\star \\end{align*} 其中第一个不等号是因为z_e^\\star \\ge 0；第二个不等号是因为对任意e \\in \\delta_{\\text{out}}(\\Scal)有z_e^\\star \\ge 1；第三个不等号是因为c_e是边e的流量上限；第四个不等号是因为\\delta_{\\text{out}}(\\Scal)上的流量未必会全部进入汇点，可能会有一部分通过\\delta_{\\text{in}}(\\Scal)再折回\\Scal；第五个不等号是因为弱对偶性。 　　综上所有的不等号都取等号，由此可以得到一些有趣的结论： 根据第一个不等号取等号，对任意e \\not \\in \\delta_{\\text{out}}(\\Scal)有z_e^\\star = 0，即对任意\\delta(\\Scal)、\\delta(\\overline{\\Scal})、\\delta_{\\text{in}}(\\Scal)中的边e，都有z_e^\\star = 0； 根据第二个不等号取等号，对任意e = (u,v) \\in \\delta_{\\text{out}}(\\Scal)有z_e^\\star = 1，故只可能是w_u^\\star = 0、w_v^\\star = -1，于是对任意e = (p, u) \\in \\delta(\\Scal)，必然有w_p^\\star = 0，否则z_e^\\star \\ge w_p^\\star - w_u^\\star > 0，与前一个结论矛盾，依此类推，对所有\\Scal中的点u都有w_u^\\star = 0。同理，对所有\\overline{\\Scal}中的点v都有w_v^\\star = -1； 根据第三个不等号取等号，当流量达到最大时，\\delta_{\\text{out}}(\\Scal)中每条边的流量都达到上限，这个也可由互补松弛条件z_e (x_e - c_e) = 0得到：z_e^\\star = 1 > 0 \\Longrightarrow x_e^\\star = c_e； 根据第四个不等号取等号，\\delta_{\\text{out}}(\\Scal)上的流量全部进入t，不存在折回\\Scal的情况，即\\delta_{\\text{in}}(\\Scal)上的流量为零，这个也可由互补松弛条件y_e x_e = 0得到：z_e^\\star = 0 > -1 = w_u^\\star - w_v^\\star，故y_e^\\star = z_e^\\star - (w_u^\\star - w_v^\\star) > 0，从而x_e^\\star = 0。 Copyright © Avanti 2020 all right reserved，powered by Gitbook文件最后修改时间： 2021-06-19 10:20:29 "}}